[{"title":"Hello World","url":"/2020/10/05/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"HBase","url":"/2020/10/05/HBase/","content":"HBase在HBase环境下，创建student表\n进入HBase\n\ncd /usr/local/hbase/bin./hbase shell\n\n\n创建student表\n\n&gt; create &#x27;student&#x27;,&#x27;info&#x27;&gt; put &#x27;student&#x27;,&#x27;1&#x27;,&#x27;info:name&#x27;,&#x27;James&#x27;&gt; put &#x27;student&#x27;,&#x27;1&#x27;,&#x27;info:gender&#x27;,&#x27;M&#x27;&gt; put &#x27;student&#x27;,&#x27;1&#x27;,&#x27;info:age&#x27;,&#x27;35&#x27;&gt; put &#x27;student&#x27;,&#x27;2&#x27;,&#x27;info:name&#x27;,&#x27;SmithGr&#x27;&gt; put &#x27;student&#x27;,&#x27;2&#x27;,&#x27;info:gender&#x27;,&#x27;M&#x27;&gt; put &#x27;student&#x27;,&#x27;2&#x27;,&#x27;info:age&#x27;,&#x27;33&#x27;&gt; exit\n\n读取HBase中student表\n编写python文件\n\nfrom pyspark import SparkConf, SparkContextconf = SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;ReadHBase&quot;)sc = SparkContext(conf = conf)host = &#x27;master&#x27;table = &#x27;student&#x27;conf = &#123;&quot;hbase.zookeeper.quorum&quot;: host, &quot;hbase.mapreduce.inputtable&quot;: table&#125;keyConv = &quot;org.apache.spark.examples.pythonconverters.ImmutableBytesWritableToStringConverter&quot;valueConv = &quot;org.apache.spark.examples.pythonconverters.HBaseResultToStringConverter&quot;hbase_rdd = sc.newAPIHadoopRDD(&quot;org.apache.hadoop.hbase.mapreduce.TableInputFormat&quot;,&quot;org.apache.hadoop.hbase.io.ImmutableBytesWritable&quot;,&quot;org.apache.hadoop.hbase.client.Result&quot;,keyConverter=keyConv,valueConverter=valueConv,conf=conf)count = hbase_rdd.count()hbase_rdd.cache()output = hbase_rdd.collect()for (k, v) in output:        print (k, v)\n\n\n执行代码\n\nspark-submit examples/readhbase.py\n\n向HBase写入数据\n编写python文件\n\nfrom pyspark import SparkConf, SparkContextconf = SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;ReadHBase&quot;)sc = SparkContext(conf = conf)host = &#x27;master&#x27;table = &#x27;student&#x27;keyConv = &quot;org.apache.spark.examples.pythonconverters.StringToImmutableBytesWritableConverter&quot;valueConv = &quot;org.apache.spark.examples.pythonconverters.StringListToPutConverter&quot;conf = &#123;&quot;hbase.zookeeper.quorum&quot;: host,&quot;hbase.mapred.outputtable&quot;: table,&quot;mapreduce.outputformat.class&quot;: &quot;org.apache.hadoop.hbase.mapreduce.TableOutputFormat&quot;,&quot;mapreduce.job.output.key.class&quot;: &quot;org.apache.hadoop.hbase.io.ImmutableBytesWritable&quot;,&quot;mapreduce.job.output.value.class&quot;: &quot;org.apache.hadoop.io.Writable&quot;&#125;rawData = [&#x27;3,info,name,Rongcheng&#x27;,&#x27;3,info,gender,M&#x27;,&#x27;3,info,age,26&#x27;,&#x27;4,info,name,Guanhua&#x27;,&#x27;4,info,gender,M&#x27;,&#x27;4,info,age,27&#x27;]sc.parallelize(rawData).map(lambda x: (x[0],x.split(&#x27;,&#x27;))).saveAsNewAPIHadoopDataset(conf=conf,keyConverter=keyConv,valueConverter=valueConv)\n\n\n执行代码\n\nspark-submit examples/writehbase.py\n\n"},{"title":"Leetcode刷题","url":"/2020/10/05/LeetcodeProblem/","content":"Leetcode刷题数据结构"},{"title":"Nginx学习","url":"/2020/10/05/Nginx/","content":"Nginx学习一、集群1、什么是集群（分布式服务器架构）\n集：合在一起、放在一起\n群：一堆、很多\n服务器架构集群：多台服务器组成的响应大并发，高数据量访问的架构体系。\n特点：\n成本高\n能够降低单台服务器的压力，使流量平均分配到多台服务器\n使网站服务架构更加安全稳定\n\n\n\n\n服务器：提供某种或者多种服务（功能）的机器（计算机）\n硬件：性能较好的电脑主机\n软件：实现各种服务支持的协议的软件\n\n\n\n1.1、web服务软件\n功能：提供http、https协议的服务器，网站网页访问的功能。\n服务\napache：老牌的服务器软件，功能多并且稳定，支持多种配置，lamp环境\nnginx:（俄罗斯人开发）安装简单小巧，并发量高，正在发展中，可以做web服务器、代理（反代理）服务器、邮箱服务器，lnmp环境\n国内淘宝定制版的nginx:tengine（由淘宝网发起的web服务器项目，它在nginx的基础上针对大访问量网站的需求，添加了很多高级功能和特性\nIIS：微软公司，为ASP脚本使用，可以通过fast-cgi（网络接口服务）的方式使用php\nlighttpd：德国开发软件，小巧，提供web服务支持，cpu占有率低，访问速度快\n\n\n\n1.2、数据库\n关系型数据库（RDBMS）\nmysql：开源，属于oracle\nmariadb：mysql的一个分支，语法类似于mysql\npostgresql：加州伯克利大学，学院派\noracle：大型商业数据库\nsqlserver：微软数据库\nDB2：IBM公司的数据库\nsqllite3：手机端（iOS和安卓）使用\n\n\n非关系型数据库\nmemcached\nredis\nmongodb\n\n\n\n1.3、负载均衡　　负载均衡服务器，分发请求到不同的服务器，使流量平均分配。\n　　服务器死机，称为宕机。\n\n硬件级别：F5，性能好，价格高\n软件级别：性价比高\nlvs：Linux下分发软件\nnginx：upstream功能分发\n\n\n\n1.4、资源服务器　　资源服务器存储静态资源，css、js、图片、视频等。一般此服务器会有硬盘（ssd固态）读写快速，带宽更大。\n1.5、反向代理　　反向代理服务器具有代理请求到对应的服务器的功能，也具有缓存的功能。\n\n代理服务器：举个栗子，a要访问c，但a不能访问c；b可以访问c，a可以访问c；所以a告诉b，帮忙访问c，把c的数据返回给a。\n正向代理：内网访问外网\n反向代理：外网访问内网\nsquid\nvarnish：高性能的开源http加速器。\nnginx\n\n\n\n\n\n1.6、高可用　　高可用服务器，用来监控负载均衡服务器，如果一旦负载均衡服务器宕机，会接替负载均衡服务器的工作，继续进行网络的分发工作。可以认为是负载均衡服务器的备用服务器。\n\nheartbit：心脏敲击\nkeeplive：保持活跃\n\n1.7、缓存软件\nmemcached\nredis\n\n1.8、cdn内容分发　　cdn：（Content Delivery Network）内容分发网络。基本思路是尽可能避开影响速度的瓶颈和环节，通过在网络各处放置节点服务器所构成的在现有的互联网基础之一的一层智能虚拟网络，cdn系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。\n\n"},{"title":"Docker学习","url":"/2020/10/05/docker/","content":"Docker学习\n\n1.Docker简介1.1 什么是虚拟化　　在计算机中，虚拟化（Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可分割的障碍，使用户可以比原来的组态更好的方式来应用这些资源。这些资源的新虚拟部分是不受现有资源的架设方式、地域或物理组态所限制的。一般所指的虚拟化资源包括计算能力和资料存储。\n　　虚拟化的技术有很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化、桌面虚拟化、服务虚拟化和虚拟机等。\n1.2 什么是Docker　　Docker是一个开源项目，诞生于2013年初，基于Go语言实现的。后来加入Linux基金会，遵从Apache2.0协议，项目代码在Github上进行维护。\n　　Docker的基础是Linux，与虚拟机不同的是，Docker只能虚拟出与宿主机相同的容器，但是占用的空间非常小，运行效率非常高。\n1.3 Docker的组件\n服务器与客户端 　　Docker是一个客户端与服务器（C/S）架构程序。客户端向服务器或守护进程发出请求，服务器或守护进程将完成工作并返回结果。\n镜像与容器 　　镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建部分”。镜像是基于联合文件系统的一种层式结构，有一系列指令一步一步构建出来。　　容器是基于镜像启动起来的，容器中可以运行一个或多个进程。镜像是Docker生命周期中的构建或是打包阶段，而容器则是启动或执行阶段。容器时基于镜像启动，一旦容器启动完成后，就可以在容器中安装自己需要的软件和服务。\nRegistry（注册中心）　　Docker用Registry来保存用户构建的镜像。分为公有和私有两部分，Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像。（Docker Hub 下在巨慢，可以构建自己的Registry）。\n\n　　Registry Hub\n2.Docker安装与启动2.1 安装Docker\nubuntu 安装\napt-get 更新 sudo apt-get update\n安装Docker sudo apt-get install docker.io\n查看版本 docker -v\n\n\ncentos 安装\nyum源更新 sudo yum update\n安装需要的软件包，yum-util提供yum-config-manager功能，另外两个是device-mapper驱动依赖的 sudo yum install -y yum-utils device-mapper-presistent-data lvm2\n设置yum源为阿里源 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n安装Docker sudo yum install docker-ce\n查看版本 docker -v\n\n\n\n2.2 设置ustc的镜像　　ustc是老牌的Linux镜像服务提供者了，还在遥远的Ubuntu5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror 的优势之一就是不需要注册，是真正的提供服务。\n　　https://lug.ustc.edu.cn/wiki/mirrors/help/docker\n　　编辑该文件：\n　　vim /etc/docker/daemon.json　　　　在文件中添加如下内容： \n&#123;&quot;registry-mirrors&quot;:[&quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125;\n\n\n2.3 Docker的启动与停止systemctl命令是系统服务管理器指令\n\n启动docker systemctl start docker\n停止docker systemctl stop docker\n重启docker systemctl restart docker\n查看docker状态 systemctl status docker\n开机启动 systemctl enable docker\n查看docker概要信息 docker info\n查看docker帮助文档 docker --help\n\n\n\n3. 常用命令3.1 镜像相关命令\n查看镜像 docker images \n\n\n\n\n字段\n含义\n\n\n\nREPOSITORY\n镜像名称\n\n\nTAG\n镜像标签\n\n\nIMAGE ID\n镜像ID\n\n\nCREATED\n镜像的创建日期\n\n\nSIZE\n镜像大小\n\n\n\n搜索镜像（需要从网络中查找需要的镜像） docker search 镜像名称 \n\n\n\n\n字段\n含义\n\n\n\nNAME\n仓库名称\n\n\nDESCRIPTION\n镜像描述\n\n\nSTARS\n用户评价，反应一个镜像的受欢迎程度\n\n\nOFFICIAL\n是否官方\n\n\nAUTOMATED\n自动创建，表示该镜像有Docker Hub自动构建流程创建的\n\n\n\n拉取镜像（从中央仓库下载到本地） docker pull 镜像名称 \n  例如，下载centos7镜像   docker pull centos:7\n\n删除镜像 docker rmi 镜像ID   删除所有镜像   docker rmi `docker images -q`    注意`,不是’\n\n\n\n\n3.2 容器相关命令\n查看容器\n查看正在运行的容器 docker ps\n查看所有容器 docker ps -s\n查看最后一次运行的容器 docker ps -l\n查看停止的容器 docker ps -f status=exited\n\n\n创建与启动容器\n创建容器命令与参数说明 docker run [参数]\n\n\n\n\n\n\n参数\n含义\n\n\n\n-i\n表示运行容器\n\n\n-t\n表示容器启动后会进入其命令行，加入这两个参数后，容器创建就能登录进去，即分配一个伪终端\n\n\n–name\n为创建的容器命名\n\n\n-v\n表示目录映射关系（前者是宿主机目录，后者是映射到宿主机的目录），可以使用多个-v做多个目录或文件映射。注意，最好做目录映射，在宿主机上做修改，然后共享到容器上\n\n\n-d\n表示创建一个守护式容器在后台运行（这样创建的容器不会自动登录容器，如果只加-i,-t两个参数，创建后就会自动进入容器\n\n\n-p\n表示端口映射，前者是宿主机端口，后者是容器内的映射端口，可以使用多个-p做多个端口映射\n\n\n"},{"title":"json学习","url":"/2020/10/05/json%E5%AD%A6%E4%B9%A0/","content":"json学习"},{"title":"nodejs及nmp","url":"/2020/10/05/nodejs%E5%8F%8Anpm/","content":"包管理工具nmp包含在nodejs中，在安装时一并安装好了\nnodejs安装\n去官网下载最新版本(nodejs官网)\n\n\n\n点击安装，选择安装路径，不建议安装在c盘，其他自己选择\n\n\n\n等待安装完成即可\n检查是否成功，打开cmd命令行，输入如下命令\n\nnode -vnpm -v\n\n\n如上图，就成功了\nnpm的配置\n在nodejs安装路径下(例如：E:\\nodejs)，新建两个文件夹，node_cache和node_global，在命令行输入如下命令\n\nnpm config set prefix &quot;E:\\nodejs\\node_global&quot;npm config set cache &quot;E:\\nodejs\\node_cache&quot;\n\n\n因为服务器在国外，使用npm包管理工具时速度可能会很慢，所以可以配置镜像加速\n\nnpm config set registry=http://registry.nom.taobao.org\n\n\n可以使用如下命令查看配置信息\n\nnpm config list\n\n配置环境变量\n在系统变量中新增NODE_PATH E:\\nodejs\\node_global\n\n\n\n在系统变量的Path中新增E:\\nodejs\\node_global\n\n\n到此为止，相关配置全部完毕了，可以正常使用了。\nnpm入门级命令\n\n\n命令\n功能\n\n\n\nnpm install appname -g\n安装插件\n\n\nnpm uninstall appname -g\n卸载插件\n\n\nnpm update appname -g\n更新插件\n\n\nnpm list\n查看安装的插件\n\n\n-g:表示全局，相当于配置了全局变量，建议 -g\n"},{"title":"notebook 主题设置","url":"/2020/10/05/notebook%E4%B8%BB%E9%A2%98/","content":"主题\n安装jupyter主题\n\npip install --upgrade jupyterthemes\n\n\n操作\n\n查看主题列表\n\njt -l\n\n\n更换主题\n\njt -t 主题名称\n\n\n恢复默认\n\njt -r\n\n\n\n字体\n字体css位置\n\n\\Anaconda\\Lib\\site-packages\\notebook\\static\\components\\codemirror\\lib\\codemirror.css\n\n\n字体样式\n在.css 文件的前几行，可直接修改\n\n字体大小\n247行，**px\n\n行间距(如果不合适，会非常难受)\n字体大小的下面\nline-height:**px\n\n\n"},{"title":"typora图床","url":"/2020/10/08/typora%E5%9B%BE%E5%BA%8A/","content":"前言​        之前一直受困于typora的图床功能，本地图片只能在本地的文件里使用，上传到博客，就是辣个样子😨(不忍直视……)\n​        现在终于好了，可以为所欲为，为所欲为……\n工具\n图床\nPicGo支持的图床\n\nSM.MS图床\n腾讯云cos\n微博图床\nGitHub图床\n七牛图床\nImgur图床\n阿里云oss\n又拍云图床\nGitee图床\n\n\n\ntypora\n\n\n​    确保版本在0.9.86以上\n\nPicGo\n版本2.2.0以上，官网下载\n\n\n配置流程这里介绍SM.MS图床，这是PicGo默认的图床。\n\n注册SM.MS图床\nSM.MS官网\n\n在PicGo中安装smms-user这个插件\n\n安装插件，需要先安装nodejs,可参考此博客，nodejs安装\n\n在SM.MS中获取API Token，粘贴到PicGo的图床设置中\n\n\n\n在Typora的文件下选择偏好设置\n\n可参考此项设置，选择自己PicGo的安装路径，可以验证图片上传是否可行\n\n这里推荐三种在Typora中使用图床的三种方式\n\n\n\n\n\n方式\n使用\n\n\n\n拖拽\n将图片直接拖入编辑区\n\n\n插入\n在编辑区内插入，快捷键Ctrl + Shift + I\n\n\n复制粘贴\n粘贴后，点击上传图片即可，（小编最喜欢这种）\n\n\n注：这里用的是SM.MS图床，现在可以拥有5G的免费空间，可以申请付费，速度还可以，可以接受，小编自己很多都是截图，大小都在(300kb)内，感觉短期内足够用\n下面给大家在提供另一种图床的配置，挂个链接吧，有需要的可以看一下\nGitee图床与Typora\n"},{"title":"Git基础","url":"/2020/10/08/Git/Untitled/","content":"内容学习自廖雪峰的Git教程\nGit基础git简介很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。\nLinus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？\n事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！\n你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。\n不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。\n安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。\nLinus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：\nLinus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。\nGit迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。\n历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。\ngit安装\nWindows\n去官网下载，选择安装路径，默认安装即可 Git官网下载\n\nLunix\n\n通常输入git可以查看如否安装，如果没有安装，会提示你安装的命令\n如果是Ubuntu或Debain可以通过sudo apt-get install git即可安装\n如果是其他版本的Linux，可以采用去官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了\n\n\nMac\n在Appstore中下载Xcode这个IDE,这是苹果系统最好的IDE，开发人员一定会下载的那种，Xcode中集成了Git，不过没有默认安装，需要运行Xcode，在Preferences中找到Downloads,选择Command Line Tools，点击install即可\n\n\n基本应用创建版本库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n\n选择一个合适的地方，创建一个空目录\nmkdir GitHubRepositorycd GitHubRepositorypwd  #显示当前目录\n\n\n注：为了避免莫名其妙的问题，建议目录(包括父目录)使用英文\n\n通过git init命令把此目录变成Git管理的仓库\ngit init\n\n\n瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。\n\n把文件添加到版本库\n首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。\n不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。\n因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。\n\n编写一个about.txt文件，内容如下\n\n我是程序员应如是Git is a version control system\n\n\n使用git add命令，把文件添加到仓库\n\ngit add about.txt\n\n\n注：LF和CRLF是两种换行方式，对于这次学习Git没影响\n\n使用git commit命令，把文件提交到仓库\n\ngit commit -m &quot;This is a message about me&quot;# -m 后面的是本次提交的说明信息，最好写的有意义，帮助别人了解此次改动的信息\n\n\n\n使用git status查看结果\n\ngit status\n\n\n注：git add &lt;file&gt;可以添加多个文件，反复使用；git commit -m &lt;message&gt;可以一次提交多个文件\n\n\n时光穿梭(版本)\n现在模仿日常工作，要对项目进行修改，我们修改about.txt文件，添加如下信息\nGit is a free software.\n\n再使用git status查看结果\n\n通过git status命令，我们可以时刻掌握仓库当前的状态，上面的命令输出告诉我们，文件被修改了，但是还没有提交修改\n\n使用git diff命令查看具体修改的内容\n\ngit diff about.txt\n\n\n\n再分别使用git add;git commit;git status命令查看状态\n\ngit add about.txtgit status#查看此时的状态git commit -m &quot;Add a message&quot;git status#再查看此时的状态\n\n\n\n版本回退\n\n使用git log命令查看文件的版本\n\ngit log\n\n\ngit log命令显示从最近到最远的提交日志\n如果嫌输出信息太多，可以加上--pretty=oneline参数\ngit log --pretty=oneline\n\n\n需要友情提示的是，你看到的一大串类似4b4258ee...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。\n\n版本回退\n\n在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n#回到上一个版本git reset --hard HEAD^\n\n\n我们已经乘坐时光机回去了\n\n想再回来\n\n如果想要再回来，就必须知道commit id，如果不记得了，git提供了后悔药\ngit refolg # 记录你的每一次命令git reset --hard 4b4258ecat about.txt\n\n\n诶嘿，我胡汉三又回来了\n注：版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。\n\n工作区和暂存区\nGit和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。\n\n工作区(Working Directory)\n\n就是你在电脑里能看到的目录，比如我的LearnMysql文件夹就是一个工作区\n\n版本库(Repository)\n\n工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。\nGit的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。\n\n\n工作流程\n\n第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；\n第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。\n\n管理修改\nGit管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。\n\n可以用git diff HEAD命令查看工作区和版本库里面最新版本的区别\n\ngit diff HEAD --about.txt\n\n\n\n撤销修改\n当你在深夜加班修改项目时，不小心在项目里添加了如下\nTMD,stupid boss\n\n嗯，难受！这个月的奖金，嗯\n\n内容只在工作区，没有使用过git add\n\ngit checkout -- about.txt\n\ngit checkout -- file可以丢弃工作区的修改\n\n\n修改被删除了\n注：git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。\n\n内容在暂存区，使用了git add命令，没使用git commit命令\n\n\n\n\n\n\n\ngit 提交信息\n查看其他人提交的修改内容或自己的历史记录的时候，提交信息是需要用到的重要资料。所以请用心填写修改内容的提交信息，以方便别人理解。以下是Git的标准注解：\n第1行：提交修改内容的摘要第2行：空行第3行以后：修改的理由\n\n\n\n\n\n- \n","categories":["Git"],"tags":["Git"]}]