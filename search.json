[{"title":"Hello World","url":"/2020/10/05/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"HBase","url":"/2020/10/05/HBase/","content":"HBase在HBase环境下，创建student表\n进入HBase\n\ncd /usr/local/hbase/bin./hbase shell\n\n\n创建student表\n\n&gt; create &#x27;student&#x27;,&#x27;info&#x27;&gt; put &#x27;student&#x27;,&#x27;1&#x27;,&#x27;info:name&#x27;,&#x27;James&#x27;&gt; put &#x27;student&#x27;,&#x27;1&#x27;,&#x27;info:gender&#x27;,&#x27;M&#x27;&gt; put &#x27;student&#x27;,&#x27;1&#x27;,&#x27;info:age&#x27;,&#x27;35&#x27;&gt; put &#x27;student&#x27;,&#x27;2&#x27;,&#x27;info:name&#x27;,&#x27;SmithGr&#x27;&gt; put &#x27;student&#x27;,&#x27;2&#x27;,&#x27;info:gender&#x27;,&#x27;M&#x27;&gt; put &#x27;student&#x27;,&#x27;2&#x27;,&#x27;info:age&#x27;,&#x27;33&#x27;&gt; exit\n\n读取HBase中student表\n编写python文件\n\nfrom pyspark import SparkConf, SparkContextconf = SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;ReadHBase&quot;)sc = SparkContext(conf = conf)host = &#x27;master&#x27;table = &#x27;student&#x27;conf = &#123;&quot;hbase.zookeeper.quorum&quot;: host, &quot;hbase.mapreduce.inputtable&quot;: table&#125;keyConv = &quot;org.apache.spark.examples.pythonconverters.ImmutableBytesWritableToStringConverter&quot;valueConv = &quot;org.apache.spark.examples.pythonconverters.HBaseResultToStringConverter&quot;hbase_rdd = sc.newAPIHadoopRDD(&quot;org.apache.hadoop.hbase.mapreduce.TableInputFormat&quot;,&quot;org.apache.hadoop.hbase.io.ImmutableBytesWritable&quot;,&quot;org.apache.hadoop.hbase.client.Result&quot;,keyConverter=keyConv,valueConverter=valueConv,conf=conf)count = hbase_rdd.count()hbase_rdd.cache()output = hbase_rdd.collect()for (k, v) in output:        print (k, v)\n\n\n执行代码\n\nspark-submit examples/readhbase.py\n\n向HBase写入数据\n编写python文件\n\nfrom pyspark import SparkConf, SparkContextconf = SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;ReadHBase&quot;)sc = SparkContext(conf = conf)host = &#x27;master&#x27;table = &#x27;student&#x27;keyConv = &quot;org.apache.spark.examples.pythonconverters.StringToImmutableBytesWritableConverter&quot;valueConv = &quot;org.apache.spark.examples.pythonconverters.StringListToPutConverter&quot;conf = &#123;&quot;hbase.zookeeper.quorum&quot;: host,&quot;hbase.mapred.outputtable&quot;: table,&quot;mapreduce.outputformat.class&quot;: &quot;org.apache.hadoop.hbase.mapreduce.TableOutputFormat&quot;,&quot;mapreduce.job.output.key.class&quot;: &quot;org.apache.hadoop.hbase.io.ImmutableBytesWritable&quot;,&quot;mapreduce.job.output.value.class&quot;: &quot;org.apache.hadoop.io.Writable&quot;&#125;rawData = [&#x27;3,info,name,Rongcheng&#x27;,&#x27;3,info,gender,M&#x27;,&#x27;3,info,age,26&#x27;,&#x27;4,info,name,Guanhua&#x27;,&#x27;4,info,gender,M&#x27;,&#x27;4,info,age,27&#x27;]sc.parallelize(rawData).map(lambda x: (x[0],x.split(&#x27;,&#x27;))).saveAsNewAPIHadoopDataset(conf=conf,keyConverter=keyConv,valueConverter=valueConv)\n\n\n执行代码\n\nspark-submit examples/writehbase.py\n\n"},{"title":"Leetcode刷题","url":"/2020/10/05/LeetcodeProblem/","content":"Leetcode刷题数据结构"},{"title":"Nginx学习","url":"/2020/10/05/Nginx/","content":"Nginx学习一、集群1、什么是集群（分布式服务器架构）\n集：合在一起、放在一起\n群：一堆、很多\n服务器架构集群：多台服务器组成的响应大并发，高数据量访问的架构体系。\n特点：\n成本高\n能够降低单台服务器的压力，使流量平均分配到多台服务器\n使网站服务架构更加安全稳定\n\n\n\n\n服务器：提供某种或者多种服务（功能）的机器（计算机）\n硬件：性能较好的电脑主机\n软件：实现各种服务支持的协议的软件\n\n\n\n1.1、web服务软件\n功能：提供http、https协议的服务器，网站网页访问的功能。\n服务\napache：老牌的服务器软件，功能多并且稳定，支持多种配置，lamp环境\nnginx:（俄罗斯人开发）安装简单小巧，并发量高，正在发展中，可以做web服务器、代理（反代理）服务器、邮箱服务器，lnmp环境\n国内淘宝定制版的nginx:tengine（由淘宝网发起的web服务器项目，它在nginx的基础上针对大访问量网站的需求，添加了很多高级功能和特性\nIIS：微软公司，为ASP脚本使用，可以通过fast-cgi（网络接口服务）的方式使用php\nlighttpd：德国开发软件，小巧，提供web服务支持，cpu占有率低，访问速度快\n\n\n\n1.2、数据库\n关系型数据库（RDBMS）\nmysql：开源，属于oracle\nmariadb：mysql的一个分支，语法类似于mysql\npostgresql：加州伯克利大学，学院派\noracle：大型商业数据库\nsqlserver：微软数据库\nDB2：IBM公司的数据库\nsqllite3：手机端（iOS和安卓）使用\n\n\n非关系型数据库\nmemcached\nredis\nmongodb\n\n\n\n1.3、负载均衡　　负载均衡服务器，分发请求到不同的服务器，使流量平均分配。\n　　服务器死机，称为宕机。\n\n硬件级别：F5，性能好，价格高\n软件级别：性价比高\nlvs：Linux下分发软件\nnginx：upstream功能分发\n\n\n\n1.4、资源服务器　　资源服务器存储静态资源，css、js、图片、视频等。一般此服务器会有硬盘（ssd固态）读写快速，带宽更大。\n1.5、反向代理　　反向代理服务器具有代理请求到对应的服务器的功能，也具有缓存的功能。\n\n代理服务器：举个栗子，a要访问c，但a不能访问c；b可以访问c，a可以访问c；所以a告诉b，帮忙访问c，把c的数据返回给a。\n正向代理：内网访问外网\n反向代理：外网访问内网\nsquid\nvarnish：高性能的开源http加速器。\nnginx\n\n\n\n\n\n1.6、高可用　　高可用服务器，用来监控负载均衡服务器，如果一旦负载均衡服务器宕机，会接替负载均衡服务器的工作，继续进行网络的分发工作。可以认为是负载均衡服务器的备用服务器。\n\nheartbit：心脏敲击\nkeeplive：保持活跃\n\n1.7、缓存软件\nmemcached\nredis\n\n1.8、cdn内容分发　　cdn：（Content Delivery Network）内容分发网络。基本思路是尽可能避开影响速度的瓶颈和环节，通过在网络各处放置节点服务器所构成的在现有的互联网基础之一的一层智能虚拟网络，cdn系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。\n\n"},{"title":"Docker学习","url":"/2020/10/05/docker/","content":"Docker学习\n\n1.Docker简介1.1 什么是虚拟化　　在计算机中，虚拟化（Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可分割的障碍，使用户可以比原来的组态更好的方式来应用这些资源。这些资源的新虚拟部分是不受现有资源的架设方式、地域或物理组态所限制的。一般所指的虚拟化资源包括计算能力和资料存储。\n　　虚拟化的技术有很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化、桌面虚拟化、服务虚拟化和虚拟机等。\n1.2 什么是Docker　　Docker是一个开源项目，诞生于2013年初，基于Go语言实现的。后来加入Linux基金会，遵从Apache2.0协议，项目代码在Github上进行维护。\n　　Docker的基础是Linux，与虚拟机不同的是，Docker只能虚拟出与宿主机相同的容器，但是占用的空间非常小，运行效率非常高。\n1.3 Docker的组件\n服务器与客户端 　　Docker是一个客户端与服务器（C/S）架构程序。客户端向服务器或守护进程发出请求，服务器或守护进程将完成工作并返回结果。\n镜像与容器 　　镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建部分”。镜像是基于联合文件系统的一种层式结构，有一系列指令一步一步构建出来。　　容器是基于镜像启动起来的，容器中可以运行一个或多个进程。镜像是Docker生命周期中的构建或是打包阶段，而容器则是启动或执行阶段。容器时基于镜像启动，一旦容器启动完成后，就可以在容器中安装自己需要的软件和服务。\nRegistry（注册中心）　　Docker用Registry来保存用户构建的镜像。分为公有和私有两部分，Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像。（Docker Hub 下在巨慢，可以构建自己的Registry）。\n\n　　Registry Hub\n2.Docker安装与启动2.1 安装Docker\nubuntu 安装\napt-get 更新 sudo apt-get update\n安装Docker sudo apt-get install docker.io\n查看版本 docker -v\n\n\ncentos 安装\nyum源更新 sudo yum update\n安装需要的软件包，yum-util提供yum-config-manager功能，另外两个是device-mapper驱动依赖的 sudo yum install -y yum-utils device-mapper-presistent-data lvm2\n设置yum源为阿里源 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n安装Docker sudo yum install docker-ce\n查看版本 docker -v\n\n\n\n2.2 设置ustc的镜像　　ustc是老牌的Linux镜像服务提供者了，还在遥远的Ubuntu5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror 的优势之一就是不需要注册，是真正的提供服务。\n　　https://lug.ustc.edu.cn/wiki/mirrors/help/docker\n　　编辑该文件：\n　　vim /etc/docker/daemon.json　　　　在文件中添加如下内容： \n&#123;&quot;registry-mirrors&quot;:[&quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125;\n\n\n2.3 Docker的启动与停止systemctl命令是系统服务管理器指令\n\n启动docker systemctl start docker\n停止docker systemctl stop docker\n重启docker systemctl restart docker\n查看docker状态 systemctl status docker\n开机启动 systemctl enable docker\n查看docker概要信息 docker info\n查看docker帮助文档 docker --help\n\n\n\n3. 常用命令3.1 镜像相关命令\n查看镜像 docker images \n\n\n\n\n字段\n含义\n\n\n\nREPOSITORY\n镜像名称\n\n\nTAG\n镜像标签\n\n\nIMAGE ID\n镜像ID\n\n\nCREATED\n镜像的创建日期\n\n\nSIZE\n镜像大小\n\n\n\n搜索镜像（需要从网络中查找需要的镜像） docker search 镜像名称 \n\n\n\n\n字段\n含义\n\n\n\nNAME\n仓库名称\n\n\nDESCRIPTION\n镜像描述\n\n\nSTARS\n用户评价，反应一个镜像的受欢迎程度\n\n\nOFFICIAL\n是否官方\n\n\nAUTOMATED\n自动创建，表示该镜像有Docker Hub自动构建流程创建的\n\n\n\n拉取镜像（从中央仓库下载到本地） docker pull 镜像名称 \n  例如，下载centos7镜像   docker pull centos:7\n\n删除镜像 docker rmi 镜像ID   删除所有镜像   docker rmi `docker images -q`    注意`,不是’\n\n\n\n\n3.2 容器相关命令\n查看容器\n查看正在运行的容器 docker ps\n查看所有容器 docker ps -s\n查看最后一次运行的容器 docker ps -l\n查看停止的容器 docker ps -f status=exited\n\n\n创建与启动容器\n创建容器命令与参数说明 docker run [参数]\n\n\n\n\n\n\n参数\n含义\n\n\n\n-i\n表示运行容器\n\n\n-t\n表示容器启动后会进入其命令行，加入这两个参数后，容器创建就能登录进去，即分配一个伪终端\n\n\n–name\n为创建的容器命名\n\n\n-v\n表示目录映射关系（前者是宿主机目录，后者是映射到宿主机的目录），可以使用多个-v做多个目录或文件映射。注意，最好做目录映射，在宿主机上做修改，然后共享到容器上\n\n\n-d\n表示创建一个守护式容器在后台运行（这样创建的容器不会自动登录容器，如果只加-i,-t两个参数，创建后就会自动进入容器\n\n\n-p\n表示端口映射，前者是宿主机端口，后者是容器内的映射端口，可以使用多个-p做多个端口映射\n\n\n"},{"title":"json学习","url":"/2020/10/05/json%E5%AD%A6%E4%B9%A0/","content":"json学习"},{"title":"nodejs及nmp","url":"/2020/10/05/nodejs%E5%8F%8Anpm/","content":"包管理工具nmp包含在nodejs中，在安装时一并安装好了\nnodejs安装\n去官网下载最新版本(nodejs官网)\n\n\n\n点击安装，选择安装路径，不建议安装在c盘，其他自己选择\n\n\n\n等待安装完成即可\n检查是否成功，打开cmd命令行，输入如下命令\n\nnode -vnpm -v\n\n\n如上图，就成功了\nnpm的配置\n在nodejs安装路径下(例如：E:\\nodejs)，新建两个文件夹，node_cache和node_global，在命令行输入如下命令\n\nnpm config set prefix &quot;E:\\nodejs\\node_global&quot;npm config set cache &quot;E:\\nodejs\\node_cache&quot;\n\n\n因为服务器在国外，使用npm包管理工具时速度可能会很慢，所以可以配置镜像加速\n\nnpm config set registry=http://registry.nom.taobao.org\n\n\n可以使用如下命令查看配置信息\n\nnpm config list\n\n配置环境变量\n在系统变量中新增NODE_PATH E:\\nodejs\\node_global\n\n\n\n在系统变量的Path中新增E:\\nodejs\\node_global\n\n\n到此为止，相关配置全部完毕了，可以正常使用了。\nnpm入门级命令\n\n\n命令\n功能\n\n\n\nnpm install appname -g\n安装插件\n\n\nnpm uninstall appname -g\n卸载插件\n\n\nnpm update appname -g\n更新插件\n\n\nnpm list\n查看安装的插件\n\n\n-g:表示全局，相当于配置了全局变量，建议 -g\n"},{"title":"notebook 主题设置","url":"/2020/10/05/notebook%E4%B8%BB%E9%A2%98/","content":"主题\n安装jupyter主题\n\npip install --upgrade jupyterthemes\n\n\n操作\n\n查看主题列表\n\njt -l\n\n\n更换主题\n\njt -t 主题名称\n\n\n恢复默认\n\njt -r\n\n\n\n字体\n字体css位置\n\n\\Anaconda\\Lib\\site-packages\\notebook\\static\\components\\codemirror\\lib\\codemirror.css\n\n\n字体样式\n在.css 文件的前几行，可直接修改\n\n字体大小\n247行，**px\n\n行间距(如果不合适，会非常难受)\n字体大小的下面\nline-height:**px\n\n\n"},{"title":"typora图床","url":"/2020/10/08/typora%E5%9B%BE%E5%BA%8A/","content":"前言​        之前一直受困于typora的图床功能，本地图片只能在本地的文件里使用，上传到博客，就是辣个样子😨(不忍直视……)\n​        现在终于好了，可以为所欲为，为所欲为……\n工具\n图床\nPicGo支持的图床\n\nSM.MS图床\n腾讯云cos\n微博图床\nGitHub图床\n七牛图床\nImgur图床\n阿里云oss\n又拍云图床\nGitee图床\n\n\n\ntypora\n\n\n​    确保版本在0.9.86以上\n\nPicGo\n版本2.2.0以上，官网下载\n\n\n配置流程这里介绍SM.MS图床，这是PicGo默认的图床。\n\n注册SM.MS图床\nSM.MS官网\n\n在PicGo中安装smms-user这个插件\n\n安装插件，需要先安装nodejs,可参考此博客，nodejs安装\n\n在SM.MS中获取API Token，粘贴到PicGo的图床设置中\n\n\n\n在Typora的文件下选择偏好设置\n\n可参考此项设置，选择自己PicGo的安装路径，可以验证图片上传是否可行\n\n这里推荐三种在Typora中使用图床的三种方式\n\n\n\n\n\n方式\n使用\n\n\n\n拖拽\n将图片直接拖入编辑区\n\n\n插入\n在编辑区内插入，快捷键Ctrl + Shift + I\n\n\n复制粘贴\n粘贴后，点击上传图片即可，（小编最喜欢这种）\n\n\n注：这里用的是SM.MS图床，现在可以拥有5G的免费空间，可以申请付费，速度还可以，可以接受，小编自己很多都是截图，大小都在(300kb)内，感觉短期内足够用\n下面给大家在提供另一种图床的配置，挂个链接吧，有需要的可以看一下\nGitee图床与Typora\n"},{"title":"Git使用","url":"/2020/10/12/Git/Git%E4%BD%BF%E7%94%A8/","content":"远程仓库Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分\n其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉\n实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。\n完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。\n在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：\n第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：\n\n\n点“Add Key”，你就应该看到已经添加的Key：\n\n为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。\n当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。\n最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。\n如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。\n确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。\n添加远程库现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作\n\n在GitHub上创建一个远程库\n登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：\n\n\n关联本地库和远程库\n目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\ngit remote add origin git@github.com:yourname/LearnMysql.git\n\nyourname替换成你自己的GitHub用户名\n添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。\n#查看当前远程库的名字git remote -v #移除一个远程库git remote remove &lt;name&gt;\n\n\n\n本地库推到远程库\ngit push -u origin master\n\n把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n\n以后每次本地进行了修改，都可以推送到GitHub上\ngit push origin master\n\n\n\n从远程库克隆\n克隆\ngit clone git@github.com:yourname/LearnMysql.git\n\n\n\n\n分支管理分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。\n如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！\n\n分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。\n现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。\n创建与合并分支在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。\n原理\n一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：\n\n\n每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。\n当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：\n\n\nGit创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！\n不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：\n\n\n假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：\n\n\n合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：\n\n\n\n实战\n首先，我们创建dev分支，然后切换到dev分支：\n\n$ git checkout -b devSwitched to a new branch &#x27;dev&#x27;\n\ngit checkout命令加上-b参数表示创建并切换，相当于以下两条命令：\n$ git branch dev$ git checkout devSwitched to branch &#x27;dev&#x27;\n\n\n然后，用git branch命令查看当前分支：\n\n$ git branch* dev  master\n\ngit branch命令会列出所有分支，当前分支前面会标一个*号。\n然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：\nCreating a new branch is quick.\n\n然后提交：\n$ git add readme.txt $ git commit -m &quot;branch test&quot;[dev b17d20e] branch test 1 file changed, 1 insertion(+)\n\n现在，dev分支的工作完成，我们就可以切换回master分支：\n$ git checkout masterSwitched to branch &#x27;master&#x27;\n\n切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：\n\n\n现在，我们把dev分支的工作成果合并到master分支上：\n\n$ git merge devUpdating d46f35e..b17d20eFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+)\n\ngit merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。\n注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。\n\n合并完成后，就可以放心地删除dev分支了：\n\n$ git branch -d devDeleted branch dev (was b17d20e).\n\n删除后，查看branch，就只剩下master分支了：\n$ git branch* master\n\n因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。\n\nswitch\n\n我们注意到切换分支使用git checkout ，而前面讲过的撤销修改则是git checkout -- ，同一个命令，有两种作用，确实有点令人迷惑。\n实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的git switch命令来切换分支：\n创建并切换到新的dev分支，可以使用：\n$ git switch -c dev\n\n直接切换到已有的master分支，可以使用：\n$ git switch master\n\n使用新的git switch命令，比git checkout要更容易理解。\n分支冲突人生不如意之事十之八九，合并分支往往也不是一帆风顺的。\n\n准备新的feature1分支，继续我们的新分支开发：\n\n$ git switch -c feature1Switched to a new branch &#x27;feature1&#x27;\n\n修改readme.txt最后一行，改为：\nCreating a new branch is quick AND simple.\n\n在feature1分支上提交：\n$ git add readme.txt$ git commit -m &quot;AND simple&quot;[feature1 14096d0] AND simple 1 file changed, 1 insertion(+), 1 deletion(-)\n\n\n切换到master分支：\n\n$ git switch masterSwitched to branch &#x27;master&#x27;Your branch is ahead of &#x27;origin/master&#x27; by 1 commit.  (use &quot;git push&quot; to publish your local commits)\n\nGit还会自动提示我们当前master分支比远程的master分支要超前1个提交。\n在master分支上把readme.txt文件的最后一行改为：\nCreating a new branch is quick &amp; simple.\n\n提交：\n$ git add readme.txt $ git commit -m &quot;&amp; simple&quot;[master 5dc6824] &amp; simple 1 file changed, 1 insertion(+), 1 deletion(-)\n\n现在，master分支和feature1分支各自都分别有新的提交，变成了这样：\n\n\n这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：\n\n$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result.\n\n果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：\n$ git statusOn branch masterYour branch is ahead of &#x27;origin/master&#x27; by 2 commits.  (use &quot;git push&quot; to publish your local commits)You have unmerged paths.  (fix conflicts and run &quot;git commit&quot;)  (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths:  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)\tboth modified:   readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)\n\n我们可以直接查看readme.txt的内容：\nGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1\n\nGit用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：\nCreating a new branch is quick and simple.\n\n再提交：\n$ git add readme.txt $ git commit -m &quot;conflict fixed&quot;[master cf810e4] conflict fixed\n\n现在，master分支和feature1分支变成了下图所示：\n\n\n用带参数的git log也可以看到分支的合并情况：\n\n$ git log --graph --pretty=oneline --abbrev-commit*   cf810e4 (HEAD -&gt; master) conflict fixed|\\  | * 14096d0 (feature1) AND simple* | 5dc6824 &amp; simple|/  * b17d20e branch test* d46f35e (origin/master) remove test.txt* b84166e add test.txt* 519219b git tracks changes* e43a48b understand how stage works* 1094adb append GPL* e475afc add distributed* eaadf4e wrote a readme file\n\n最后，删除feature1分支：\n$ git branch -d feature1Deleted branch feature1 (was 14096d0).\n\n分支管理策略原理通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\n如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n下面我们实战一下--no-ff方式的git merge：\n\n首先，仍然创建并切换dev分支：\n\n$ git switch -c devSwitched to a new branch &#x27;dev&#x27;\n\n修改readme.txt文件，并提交一个新的commit：\n$ git add readme.txt $ git commit -m &quot;add merge&quot;[dev f52c633] add merge 1 file changed, 1 insertion(+)\n\n\n现在，我们切换回master：\n\n$ git switch masterSwitched to branch &#x27;master&#x27;\n\n准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward：\n$ git merge --no-ff -m &quot;merge with no-ff&quot; devMerge made by the &#x27;recursive&#x27; strategy. readme.txt | 1 + 1 file changed, 1 insertion(+)\n\n\n因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。\n\n合并后，我们用git log看看分支历史：\n$ git log --graph --pretty=oneline --abbrev-commit*   e1e9c68 (HEAD -&gt; master) merge with no-ff|\\  | * f52c633 (dev) add merge|/  *   cf810e4 conflict fixed...\n\n可以看到，不使用Fast forward模式，merge后就像这样：\n\n实际开发中首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\n那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；\n你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。\n所以，团队合作的分支看起来就像这样：\n\nBug分支软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。\n\n当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：\n\n$ git statusOn branch devChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)\tnew file:   hello.pyChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\tmodified:   readme.txt\n\n并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？\n\n幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：\n\n$ git stashSaved working directory and index state WIP on dev: f52c633 add merge\n\n现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。\n\n首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：\n\n$ git checkout masterSwitched to branch &#x27;master&#x27;Your branch is ahead of &#x27;origin/master&#x27; by 6 commits.  (use &quot;git push&quot; to publish your local commits)$ git checkout -b issue-101Switched to a new branch &#x27;issue-101&#x27;\n\n\n现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：\n\n$ git add readme.txt $ git commit -m &quot;fix bug 101&quot;[issue-101 4c805e2] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-)\n\n\n修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：\n\n$ git switch masterSwitched to branch &#x27;master&#x27;Your branch is ahead of &#x27;origin/master&#x27; by 6 commits.  (use &quot;git push&quot; to publish your local commits)$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101Merge made by the &#x27;recursive&#x27; strategy. readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)\n\n\n太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！\n\n$ git switch devSwitched to branch &#x27;dev&#x27;$ git statusOn branch devnothing to commit, working tree clean\n\n\n工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：\n\n$ git stash liststash@&#123;0&#125;: WIP on dev: f52c633 add merge\n\n工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：\n\n一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；\n\n另一种方式是用git stash pop，恢复的同时把stash内容也删了：\n\n\n$ git stash popOn branch devChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)\tnew file:   hello.pyChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)\tmodified:   readme.txtDropped refs/stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a)\n\n再用git stash list查看，就看不到任何stash内容了：\n$ git stash list\n\n你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：\n$ git stash apply stash@&#123;0&#125;\n\n\n在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。\n\n​     那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？\n​     有木有更简单的方法？\n​     有！\n\n同样的bug，要在dev上修复，我们只需要把4c805e2 fix bug 101这个         提交所做的修改“复制”到dev分支。注意：我们只想复制4c805e2 fix bug 101这个提交所做的修改，并不是把整个master分支merge过来。\n\n为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支：\n\n\n$ git branch* dev  master$ git cherry-pick 4c805e2[master 1d4b803] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-)\n\n\nGit自动给dev分支做了一次提交，注意这次提交的commit是1d4b803，它并不同于master的4c805e2，因为这两个commit只是改动相同，但确实是两个不同的commit。用git cherry-pick，我们就不需要在dev分支上手动再把修bug的过程重复一遍。\n\n既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要git stash命令保存现场，才能从dev分支切换到master分支。\n\n\nFeature分支软件开发中，总有无穷无尽的新的功能要不断添加进来。\n添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。\n现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。\n\n于是准备开发：\n\n$ git switch -c feature-vulcanSwitched to a new branch &#x27;feature-vulcan&#x27;\n\n5分钟后，开发完毕：\n$ git add vulcan.py$ git statusOn branch feature-vulcanChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)\tnew file:   vulcan.py$ git commit -m &quot;add feature vulcan&quot;[feature-vulcan 287773e] add feature vulcan 1 file changed, 2 insertions(+) create mode 100644 vulcan.py\n\n切回dev，准备合并：\n$ git switch dev\n\n一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。\n\n但是！\n\n就在此时，接到上级命令，因经费不足，新功能必须取消！\n虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：\n$ git branch -d feature-vulcanerror: The branch &#x27;feature-vulcan&#x27; is not fully merged.If you are sure you want to delete it, run &#x27;git branch -D feature-vulcan&#x27;.\n\n销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。\n现在我们强行删除：\n$ git branch -D feature-vulcanDeleted branch feature-vulcan (was 287773e).\n\n终于删除成功！\n多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。\n\n要查看远程库的信息，用git remote：\n\n$ git remoteorigin\n\n\n或者，用git remote -v显示更详细的信息：\n\n$ git remote -vorigin  git@github.com:michaelliao/learngit.git (fetch)origin  git@github.com:michaelliao/learngit.git (push)\n\n上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。\n推送分支\n推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：\n\n$ git push origin master\n\n如果要推送其他分支，比如dev，就改成：\n$ git push origin dev\n\n\n但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？\nmaster分支是主分支，因此要时刻与远程同步；\ndev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\nbug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\nfeature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n\n\n拉取分支多人协作时，大家都会往master和dev分支上推送各自的修改。\n\n现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：\n\n$ git clone git@github.com:michaelliao/learngit.gitCloning into &#x27;learngit&#x27;...remote: Counting objects: 40, done.remote: Compressing objects: 100% (21/21), done.remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0Receiving objects: 100% (40/40), done.Resolving deltas: 100% (14/14), done.\n\n当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看：\n$ git branch* master\n\n\n现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：\n\n$ git checkout -b dev origin/dev\n\n现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：\n$ git add env.txt$ git commit -m &quot;add env&quot;[dev 7a5e5dd] add env 1 file changed, 1 insertion(+) create mode 100644 env.txt$ git push origin devCounting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git   f52c633..7a5e5dd  dev -&gt; dev\n\n\n小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：\n\n$ cat env.txtenv$ git add env.txt$ git commit -m &quot;add new env&quot;[dev 7bd91f1] add new env 1 file changed, 1 insertion(+) create mode 100644 env.txt$ git push origin devTo github.com:michaelliao/learngit.git ! [rejected]        dev -&gt; dev (non-fast-forward)error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: &#x27;git pull ...&#x27;) before pushing again.hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.\n\n\n推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：\n\n$ git pullThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details.    git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with:    git branch --set-upstream-to=origin/&lt;branch&gt; dev\n\n\ngit pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：\n\n$ git branch --set-upstream-to=origin/dev devBranch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.\n\n再pull：\n$ git pullAuto-merging env.txtCONFLICT (add/add): Merge conflict in env.txtAutomatic merge failed; fix conflicts and then commit the result.\n\n这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：\n$ git commit -m &quot;fix env conflict&quot;[dev 57c53ab] fix env conflict$ git push origin devCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (4/4), done.Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.Total 6 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git   7a5e5dd..57c53ab  dev -&gt; dev\n\n小结因此，多人协作的工作模式通常是这样：\n\n首先，可以试图用git push origin 推送自己的修改；\n如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\n如果合并有冲突，则解决冲突，并在本地提交；\n没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！\n\n如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to  origin/。\n这就是多人协作的工作模式，一旦熟悉了，就非常简单。\nRebase多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。\n\n每次合并再push后，分支变成了这样：\n\n$ git log --graph --pretty=oneline --abbrev-commit* d1be385 (HEAD -&gt; master, origin/master) init hello*   e5e69f1 Merge branch &#x27;dev&#x27;|\\  | *   57c53ab (origin/dev, dev) fix env conflict| |\\  | | * 7a5e5dd add env| * | 7bd91f1 add new env| |/  * |   12a631b merged bug fix 101|\\ \\  | * | 4c805e2 fix bug 101|/ /  * |   e1e9c68 merge with no-ff|\\ \\  | |/  | * f52c633 add merge|/  *   cf810e4 conflict fixed\n\n总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？\n\nGit有一种称为rebase的操作，有人把它翻译成“变基”。\n\n在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看：\n$ git log --graph --pretty=oneline --abbrev-commit* 582d922 (HEAD -&gt; master) add author* 8875536 add comment* d1be385 (origin/master) init hello*   e5e69f1 Merge branch &#x27;dev&#x27;|\\  | *   57c53ab (origin/dev, dev) fix env conflict| |\\  | | * 7a5e5dd add env| * | 7bd91f1 add new env...\n\n注意到Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。\n\n现在我们尝试推送本地分支：\n\n$ git push origin masterTo github.com:michaelliao/learngit.git ! [rejected]        master -&gt; master (fetch first)error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &#x27;git pull ...&#x27;) before pushing again.hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.\n\n\n很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：\n\n$ git pullremote: Counting objects: 3, done.remote: Compressing objects: 100% (1/1), done.remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:michaelliao/learngit   d1be385..f005ed4  master     -&gt; origin/master * [new tag]         v1.0       -&gt; v1.0Auto-merging hello.pyMerge made by the &#x27;recursive&#x27; strategy. hello.py | 1 + 1 file changed, 1 insertion(+)\n\n\n再用git status看看状态：\n\n$ git statusOn branch masterYour branch is ahead of &#x27;origin/master&#x27; by 3 commits.  (use &quot;git push&quot; to publish your local commits)nothing to commit, working tree clean\n\n加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。\n\n用git log看看：\n\n$ git log --graph --pretty=oneline --abbrev-commit*   e0ea545 (HEAD -&gt; master) Merge branch &#x27;master&#x27; of github.com:michaelliao/learngit|\\  | * f005ed4 (origin/master) set exit=1* | 582d922 add author* | 8875536 add comment|/  * d1be385 init hello...\n\n\n我们输入命令git rebase试试：\n\n$ git rebaseFirst, rewinding head to replay your work on top of it...Applying: add commentUsing index info to reconstruct a base tree...M\thello.pyFalling back to patching base and 3-way merge...Auto-merging hello.pyApplying: add authorUsing index info to reconstruct a base tree...M\thello.pyFalling back to patching base and 3-way merge...Auto-merging hello.py\n\n输出了一大堆操作，到底是啥效果？再用git log看看：\n$ git log --graph --pretty=oneline --abbrev-commit* 7e61ed4 (HEAD -&gt; master) add author* 3611cfe add comment* f005ed4 (origin/master) set exit=1* d1be385 init hello...\n\n原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。\n\n这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。\n\n最后，通过push操作把本地分支推送到远程：\n$ git push origin masterCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done.Total 6 (delta 2), reused 0 (delta 0)remote: Resolving deltas: 100% (2/2), completed with 1 local object.To github.com:michaelliao/learngit.git   f005ed4..7e61ed4  master -&gt; master\n\n再用git log看看效果：\n$ git log --graph --pretty=oneline --abbrev-commit* 7e61ed4 (HEAD -&gt; master, origin/master) add author* 3611cfe add comment* f005ed4 set exit=1* d1be385 init hello...\n\n远程分支的提交历史也是一条直线。\n","categories":["Git"],"tags":["Git"]},{"title":"Git基础","url":"/2020/10/08/Git/Git%E5%9F%BA%E7%A1%80/","content":"内容学习自廖雪峰的Git教程\nGit基础git简介很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。\nLinus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？\n事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！\n你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。\n不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。\n安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。\nLinus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：\nLinus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。\nGit迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。\n历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。\ngit安装\nWindows\n去官网下载，选择安装路径，默认安装即可 Git官网下载\n\nLunix\n\n通常输入git可以查看如否安装，如果没有安装，会提示你安装的命令\n如果是Ubuntu或Debain可以通过sudo apt-get install git即可安装\n如果是其他版本的Linux，可以采用去官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了\n\n\nMac\n在Appstore中下载Xcode这个IDE,这是苹果系统最好的IDE，开发人员一定会下载的那种，Xcode中集成了Git，不过没有默认安装，需要运行Xcode，在Preferences中找到Downloads,选择Command Line Tools，点击install即可\n\n\n基本应用创建版本库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n\n选择一个合适的地方，创建一个空目录\nmkdir GitHubRepositorycd GitHubRepositorypwd  #显示当前目录\n\n\n注：为了避免莫名其妙的问题，建议目录(包括父目录)使用英文\n\n通过git init命令把此目录变成Git管理的仓库\ngit init\n\n\n瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。\n\n把文件添加到版本库\n首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。\n不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。\n因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。\n\n编写一个about.txt文件，内容如下\n\n我是程序员应如是Git is a version control system\n\n\n使用git add命令，把文件添加到仓库\n\ngit add about.txt\n\n\n注：LF和CRLF是两种换行方式，对于这次学习Git没影响\n\n使用git commit命令，把文件提交到仓库\n\ngit commit -m &quot;This is a message about me&quot;# -m 后面的是本次提交的说明信息，最好写的有意义，帮助别人了解此次改动的信息\n\n\n\n使用git status查看结果\n\ngit status\n\n\n注：git add &lt;file&gt;可以添加多个文件，反复使用；git commit -m &lt;message&gt;可以一次提交多个文件\n\n\n时光穿梭(版本)\n现在模仿日常工作，要对项目进行修改，我们修改about.txt文件，添加如下信息\nGit is a free software.\n\n再使用git status查看结果\n\n通过git status命令，我们可以时刻掌握仓库当前的状态，上面的命令输出告诉我们，文件被修改了，但是还没有提交修改\n\n使用git diff命令查看具体修改的内容\n\ngit diff about.txt\n\n\n\n再分别使用git add;git commit;git status命令查看状态\n\ngit add about.txtgit status#查看此时的状态git commit -m &quot;Add a message&quot;git status#再查看此时的状态\n\n\n\n版本回退\n\n使用git log命令查看文件的版本\n\ngit log\n\n\ngit log命令显示从最近到最远的提交日志\n如果嫌输出信息太多，可以加上--pretty=oneline参数\ngit log --pretty=oneline\n\n\n需要友情提示的是，你看到的一大串类似4b4258ee...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。\n\n版本回退\n\n在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n#回到上一个版本git reset --hard HEAD^\n\n\n我们已经乘坐时光机回去了\n\n想再回来\n\n如果想要再回来，就必须知道commit id，如果不记得了，git提供了后悔药\ngit refolg # 记录你的每一次命令git reset --hard 4b4258ecat about.txt\n\n\n诶嘿，我胡汉三又回来了\n注：版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。\n\n工作区和暂存区\nGit和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。\n\n工作区(Working Directory)\n\n就是你在电脑里能看到的目录，比如我的LearnMysql文件夹就是一个工作区\n\n版本库(Repository)\n\n工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。\nGit的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。\n\n\n工作流程\n\n第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；\n第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。\n\n管理修改\nGit管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。\n\n可以用git diff HEAD命令查看工作区和版本库里面最新版本的区别\n\ngit diff HEAD --about.txt\n\n\n\n撤销修改\n当你在深夜加班修改项目时，不小心在项目里添加了如下\nTMD,stupid boss\n\n嗯，难受！这个月的奖金，嗯\n\n内容只在工作区，没有使用过git add\n\ngit checkout -- about.txt\n\ngit checkout -- file可以丢弃工作区的修改\n\n\n修改被删除了\n注：git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。\n\n内容在暂存区，使用了git add命令，没使用git commit命令\n\ngit reset HEAD about.txt#把文件从暂存区重新放回工作区\n\n现在修改在工作区，可以使用上面的命令将工作区的修改删除\n\n嗯，奖金总算保住了\n\n如果脑子一热，使用了git commit命令，可以通过版本回退，回到上一个版本\n\n\n\n\n\n删除文件\n现在我们有一个没用的文件test.txt,想要删除，文件已经在版本库中\n首先我们先删除工作区的文件，可以图形化删除也可以使用命令rm &lt;file&gt;\n\n现在我们有两个选择\n\n删除版本库中的文件\n\ngit rm test.txt #从版本库中删除文件git commit -m &quot;remove test.txt&quot;#也可以使用git add test.txt 代替git rm test.txt 效果一样\n\n\n\n删除了，从版本库中恢复文件\n\n#git checkout 版本库里文件的版本替换工作区里文件的版本git checkout -- test.txt\n\n\n\n\n小提示：\n\ngit 提交信息\n查看其他人提交的修改内容或自己的历史记录的时候，提交信息是需要用到的重要资料。所以请用心填写修改内容的提交信息，以方便别人理解。以下是Git的标准注解：\n第1行：提交修改内容的摘要第2行：空行第3行以后：修改的理由\n\ngit更新\n#查看版本git --version#git版本是2.17.1之前git update#git版本是2.17.1之后git update-git-for-windows\n\n\n\n\n\n\n","categories":["Git"],"tags":["Git"]},{"title":"Git小细节","url":"/2020/10/13/Git/Git%E5%B0%8F%E7%BB%86%E8%8A%82/","content":"标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。\nGit的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。\nGit有commit，为什么还要引入tag？\n“请把上周一的那个版本打包发布，commit号是6a5819e…”\n“一串乱七八糟的数字不好找！”\n如果换一个办法：\n“请把上周一的那个版本打包发布，版本号是v1.2”\n创建标签\n在Git中打标签非常简单，首先，切换到需要打标签的分支上：\n\n$ git branch* dev  master$ git checkout masterSwitched to branch &#39;master&#39;\n\n然后，敲命令git tag 就可以打一个新标签：\n$ git tag v1.0\n\n可以用命令git tag查看所有标签：\n$ git tagv1.0\n\n\n默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？\n\n方法是找到历史提交的commit id，然后打上就可以了：\n$ git log --pretty&#x3D;oneline --abbrev-commit12a631b (HEAD -&gt; master, tag: v1.0, origin&#x2F;master) merged bug fix 1014c805e2 fix bug 101e1e9c68 merge with no-fff52c633 add mergecf810e4 conflict fixed5dc6824 &amp; simple14096d0 AND simpleb17d20e branch testd46f35e remove test.txtb84166e add test.txt519219b git tracks changese43a48b understand how stage works1094adb append GPLe475afc add distributedeaadf4e wrote a readme file\n\n比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：\n$ git tag v0.9 f52c633\n\n\n再用命令git tag查看标签：\n\n$ git tagv0.9v1.0\n\n注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show 查看标签信息：\n$ git show v0.9commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 21:56:54 2018 +0800    add mergediff --git a&#x2F;readme.txt b&#x2F;readme.txt...\n\n可以看到，v0.9确实打在add merge这次提交上。\n\n还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：\n\n$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb\n\n用命令git show 可以看到说明文字：\n$ git show v0.1tag v0.1Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 22:48:43 2018 +0800version 0.1 releasedcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date:   Fri May 18 21:06:15 2018 +0800    append GPLdiff --git a&#x2F;readme.txt b&#x2F;readme.txt...\n\n标签操作\n如果标签打错了，也可以删除：\n\n$ git tag -d v0.1Deleted tag &#39;v0.1&#39; (was f15b0dd)\n\n因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。\n如果要推送某个标签到远程，使用命令git push origin ：\n$ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao&#x2F;learngit.git * [new tag]         v1.0 -&gt; v1.0\n\n或者，一次性推送全部尚未推送到远程的本地标签：\n$ git push origin --tagsTotal 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao&#x2F;learngit.git * [new tag]         v0.9 -&gt; v0.9\n\n\n如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：\n\n$ git tag -d v0.9Deleted tag &#39;v0.9&#39; (was f52c633)\n\n然后，从远程删除。删除命令也是push，但是格式如下：\n$ git push origin :refs&#x2F;tags&#x2F;v0.9To github.com:michaelliao&#x2F;learngit.git - [deleted]         v0.9\n\n要看看是否真的从远程库删除了标签，可以登陆GitHub查看。\n","categories":["Git"],"tags":["Git"]},{"url":"/2020/10/15/MySQL/%E5%AE%89%E8%A3%85MySQL/","content":"Linux环境下安装MySQL安装MySQL使用apt包管理器进行安装\n\n首先保证你的软件包是最新的，执行下面的命令更新\n\nsudo apt-get update\n\n\n安装mysql-server软件包\n\nsudo apt install mysql-server\n\n\n根据提示完成安装，输入”yes”\n\n登录MySQL正常登录会出错(由于在安装时没有设置root密码)\nmysql -u root -p\n\n下面是没有设置root密码或root密码忘记的解决办法\n\n修改mysqld.cnf配置文件\n\n此配置文件应该在/etc/mysql/mysql.conf.d/mysqld.cnf ,使用vim编辑器进行修改\n# 在 mysqld 块中添加下面一句skip-grant-tables # 可以跳过密码直接登录\n\n\n保存退出后，需要重启MySQL服务器\nservice mysql restart #重启service mysql start #启动service mysql status #查看状态信息service mysql stop #关闭\n\n现在就可以进入mysql了，嘻嘻\n\n设置root密码\n\nmysql -u root -p # 回车进入MySQL# 分别执行下面三句话设置密码use mysql; # 回车update user set authentication_string&#x3D;password(&quot;你的密码&quot;),plugin&#x3D;&#39;mysql_native_password&#39; where user&#x3D;&#39;root&#39;; # 回车flush privileges; # 回车\n\n# 在MySQL中查看下面的语句输出的信息select user,plugin from user;\n\n\n这样即可！\n\n回去将第一步的配置文件在修改一下，将我们之前添加的语句注释掉(#)或删除，就可以用自己的密码登陆了，接下来就该是你的操作了，嘻嘻\n\n注：本文使用的是MySQL-5.7版本，如果是MySQL-8版本中，上面的修改密码的语句可能会出现错误，可以用下面的语句试试\nALTER user &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;你的密码&#39;;\n\n"},{"title":"解决Permission to xxx denied to xxx问题","url":"/2020/10/18/Git/Permission/","content":"问题场景公司有一台电脑，使用了多个账户的ssh，今天新建一个github账号的时候，想要上传到远程仓库却出现一个问题提示：\nPermission to xxx（远程仓库） denied to xxx(电脑上的账号)1\n\n大致意思是远程仓库的权限不被电脑上的github账号及其ssh秘钥所认可。\n新建ssh想一想，这是当然的了，新建的github账号在这个电脑上又没有设定ssh，于是我去新建了一个ssh：\nssh-keygen -t rsa -C &quot;XXXXXXXX&quot;1\n\n然后terminate会提示：\nEnter file in which to save the key (&#x2F;Users&#x2F;zhengrunming&#x2F;.ssh&#x2F;id_rsa): 1\n\n这里由于id_rsa这个ssh文件的名字已经被我们之前账号所占用了，所以我们随便取一个其他的名字：n\nEnter passphrase (empty for no passphrase):1\n\n输入passphrase，我这直接回车\nEnter same passphrase again:1\n\n再次确认。\n\n同步github上的ssh好啦，现在找到.ssh文件夹（就在用户目录下隐藏），打开文件夹可以看到新的ssh已经生成，n（私钥）和n.pub(公钥)\n那么我们使用\ncat n.pub1\n\n打开公钥，把里面的内容拷贝到github新建账户中的ssh key中（详见廖雪峰git教程的远程仓库那一节）\n这样第一步就完成了，本机上的ssh key已经于github账户互通\n\n查询资料再次尝试git push，可是还是提示：\nPermission to xxx（远程仓库） denied to xxx(电脑上的账号)1\n\n这就蛋疼了，问题还是没有解决。\n上网查询资料，原来是github虽然有了你的一个pub key，但是电脑上有两个ssh，其中一个才是你自己私用的，那么github就蒙了，不知道哪一个才是你新账户的ssh，这个时候就需要我们手动配置一下啦。参考：https://www.jianshu.com/p/12badb7e6c10\n\n配置ssh文件夹中的config我们打开ssh文件夹，创建config文件,如果有就不用啦\nvim config1\n\n配置一下：\n#Default GitHubHost github.comHostName github.comUser gitIdentityFile ~&#x2F;.ssh&#x2F;id_rsa#new githubHost github-boreas6HostName github.comUser gitIdentityFile ~&#x2F;.ssh&#x2F;n1234567891011\n\n这里可以清楚的看到，上面一大段是github默认的配置，也就是之前具有id_rsa账号的配置。那么我们需要仿照着新配置一个，告诉github拥有n这个ssh的账号是哪个就可以了,也就是这一段：\n#new githubHost github-boreas6&#x2F;&#x2F;修改这里HostName github.comUser gitIdentityFile ~&#x2F;.ssh&#x2F;n&#x2F;&#x2F;修改这里12345\n\n修改一下host的内容，加以辨别即可。\n\n配置远程地址再回到项目，重新配置一下远程：首先看一看之前的Host地址是什么：\ngit remote -v1\n\n返回：\norigin  git@github.com:Boreas6&#x2F;word-collection.git (fetch)origin  git@github.com:Boreas6&#x2F;word-collection.git (push)12\n\n我们这里仿照一下，把&#x67;&#105;&#x74;&#64;&#103;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;这个默认的host名称改成我们之前新设定的就可以了\ngit remote set-url origin  github-boreas6:Boreas6&#x2F;word-collection.git1\n\n再看一下有没有改成功：\ngit remote -v1\n\n返回：\norigin  github-boreas6:Boreas6&#x2F;word-collection.git (fetch)origin  github-boreas6:Boreas6&#x2F;word-collection.git (push)12\n\n修改成功！\n\n重新提交再试试提交\ngit push 1\n\n成功了！\n总结总结一下，关键点有：\n\n新建一个ssh\n\n配置config，增加新的host配置上面创建的ssh\n使用remote set-url 配置host地址\n\n\nps\n如果是之前账户确认不用的场景，直接删除ssh文件中的内容，再新建一个ssh更快哦\n使用以下代码配置新账号的用户名和邮箱\n\ngit config user.name &quot;你的另一个用户名&quot;git config user.email &quot;你的另一个邮箱&quot;","categories":["git"],"tags":["git"]},{"title":"语言对比","url":"/2020/10/25/%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94/","content":"主要列出几个流行的编程语言的基础语法，用于比较和记忆，防止记忆混乱\n\n\n\n\n\n\n\n\n\n\n\nC\nC++\nJava\nPython\nGo\n\n\n注释\nC\n\n\n单行注释\n\n//这是C的单行注释\n\n\n多行注释\n\n/*这是C语言的多行注释*/\n\n\nC++\n\n\n单行注释\n\n//这是C++的单行注释\n\n\n多行注释\n\n/*这是C++的多行注释*/\n\n\nJava\n\n\n单行注释\n\n//这是java的单行注释\n\n\n多行注释\n\n/*这是java的多行注释*/\n\n\n文档注释\n\n/**这是java的文档注释也能注释多行内容，一般用在类、方法和变量上面，用来描述其作用。注释后，鼠标放在类和变量上面会自动显示出我们注释的内容。*/\n\n\nPython\n\n\n单行注释\n\n#这是python的单行注释\n\n\n多行注释\n\n&#x27;&#x27;&#x27;这是python的多行注释&#x27;&#x27;&#x27;&quot;&quot;&quot;这也是python的多行注释&quot;&quot;&quot;\n\n\nGo\n\n\n单行注释\n\n//这个是Go的单行注释\n\n\n多行注释\n\n/*这个是Go语言的多行注释*/\n\n\n\n数据类型\nC\nC++\n\n\n整数类型\n\n\n\n\n数据类型\n占用空间\n\n\n\nshort\n2字节\n\n\nint\n4字节\n\n\nlong\nWindows为4字节；Linux为4字节(32位)、8字节(64位)\n\n\nlong long\n8字节\n\n\n\n实数类型(浮点型)\n\n\n\n\n数据类型\n占用空间\n有效数字范围\n\n\n\nfloat\n4字节\n7位有效数字\n\n\ndouble\n8字节\n15～16位有效数字\n\n\n\n字符型\n\n\n\n\n数据类型\n占用空间\n\n\n\nchar\n1字节\n\n\n\n字符串\n\n\n\n\n数据类型\n头文件\n\n\n\nstring\n#include\n\n\n\n布尔类型\n\n\n\n\n数据类型\n占用空间\n值\n\n\n\nbool\n1字节\ntrue/false\n\n\n\n转义字符\n\n\n\n\n转义字符\n含义\nASCII码值（十进制）\n\n\n\n\\a\n警报\n007\n\n\n\\b\n退格(BS) ，将当前位置移到前一列\n008\n\n\n\\f\n换页(FF)，将当前位置移到下页开头\n012\n\n\n\\n\n换行(LF) ，将当前位置移到下一行开头\n010\n\n\n\\r\n回车(CR) ，将当前位置移到本行开头\n013\n\n\n\\t\n水平制表(HT)  （跳到下一个TAB位置）\n009\n\n\n\\v\n垂直制表(VT)\n011\n\n\n\\\\\n代表一个反斜线字符”&quot;\n092\n\n\n&#39;\n代表一个单引号（撇号）字符\n039\n\n\n&quot;\n代表一个双引号字符\n034\n\n\n?\n代表一个问号\n063\n\n\n\\0\n数字0\n000\n\n\n\\ddd\n8进制转义字符，d范围0~7\n3位8进制\n\n\n\\xhh\n16进制转义字符，h范围09，af，A~F\n3位16进制\n\n\n\nJava\nPython\n\n\n简单数据类型\n\n整型&lt;class &#39;int&#39;&gt;\n浮点型&lt;class &#39;float&#39;&gt;\n布尔型&lt;class &#39;bool&#39;&gt;\n\n\n容器数据类型\n\n列表&lt;class &#39;list&#39;&gt;\n元组&lt;class &#39;tuple&#39;&gt;\n字典&lt;class &#39;dict&#39;&gt;\n集合&lt;class &#39;set&#39;&gt;\n字符串&lt;class &#39;str&#39;&gt;\n\n\n\n\nGo\n\n程序流程结构\nC\nC++\n\n\nJava\nPython\nGo\n\n"},{"title":"汉诺塔问题","url":"/2020/11/12/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/","content":"汉诺塔问题介绍汉诺塔问题是一个经典的问题。汉诺塔（Hanoi Tower），又称河内塔，源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。\n\n问题分析这里我们只考虑最常用的解法，递归方法，把所有的圆盘n分为两个部分：\n\n上层的n-1个圆盘\n最下层的第n个圆盘\n\n解题步骤：\n\n1、\n​        把n-1个圆盘，从a移动到b\n​        把第n个圆盘，从a移动到c\n2、\n​        把n-1个圆盘，从b移动到c\n\nn-1个圆盘的移动又会用相同的解题步骤来解决，直到一个圆盘为止\n程序实现\nc\n\n#include&lt;stdio.h&gt;#include&lt;string.h&gt;void hanno(int n,char a[],char b[],char c[])&#123;    if(n == 1)&#123;        printf(&quot;圆盘从%s移动到%s\\n&quot;,a,c);    &#125;    else&#123;        hanno(n - 1,a,c,b);        printf(&quot;圆盘从%s移动到%s\\n&quot;,a,c);        hanno(n - 1,b,a,c);    &#125;&#125;int main()&#123;    hanno(3,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);    return 0;&#125;\n\n结果如下：\n\n\njava\n\npackage com.smithbee.day07;public class HannoTower &#123;    public static void main(String[] args)&#123;        hannoo(3,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);    &#125;    public static void hannoo(int n,String a,String b,String c)&#123;        if(n == 1)&#123;            System.out.println(a + &quot;移动到&quot; + c);//问题的最基础的解决方式，也是递归算法结束的条件        &#125;else&#123;            hannoo(n - 1,a,c,b);//步骤一，将n-1个圆盘从a移动到b            System.out.println(a + &quot;移动到&quot; + c);//步骤一，将第n个圆盘从a移动到c            hannoo(n - 1,b,a,c);//步骤二，将n-1个圆盘从b移动到c        &#125;    &#125;&#125;\n\n结果如下：\n\n\npython \n\n#汉诺塔问题def hanno(n,a,b,c):       if n == 1:                print(&#x27;圆盘从&#123;0&#125;移动到&#123;1&#125;&#x27;.format(a,c))    else:        hanno(n - 1,a,c,b)                print(&#x27;圆盘从&#123;0&#125;移动到&#123;1&#125;&#x27;.format(a,c))        hanno(n - 1,b,a,c)        hanno(3,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)\n\n结果如下：\n\n\nc++\n\n#include&lt;iostream&gt;using namespace std;void hanno(int n,string a,string b,string c);int main()&#123;    hanno(3,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);    return 0;&#125;void hanno(int n,string a,string b,string c)&#123;    if(n == 1)&#123;        cout &lt;&lt; &quot;圆盘从&quot; &lt;&lt; a &lt;&lt; &quot;移动到&quot; &lt;&lt; c &lt;&lt;endl;    &#125;    else&#123;        hanno(n - 1,a,c,b);        cout &lt;&lt; &quot;圆盘从&quot; &lt;&lt; a &lt;&lt; &quot;移动到&quot; &lt;&lt; c &lt;&lt;endl;        hanno(n - 1,b,a,c);    &#125;&#125;\n\n结果如下：\n\n\ngo\n\npackage mainimport &quot;fmt&quot;func hanno(n int,a string,b string,c string) int &#123;\tif n == 1 &#123;\t\tfmt.Printf(&quot;圆盘从%s移动到%s\\n&quot;,a,c)\t&#125; else &#123;\t\thanno(n - 1,a,c,b)\t\tfmt.Printf(&quot;圆盘从%s移动到%s\\n&quot;,a,c)\t\thanno(n - 1,b,a,c)\t&#125;\treturn 0&#125;func main() &#123;\thanno(3,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)&#125;\n\n结果如下：\n\n递归\n递归算法的四条基本准则\n\n\n1.基准情形。必须有某些基准情形，它无需递归就能解出。2.不断推进。对于那些需要递归求解的情形，每一次递归调用都必须要使求解的状况朝接近基准情形的方向推进。3.设计法则。假设所有的递归调用都能运行。4.合成效益法则。在求解同一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作——-摘自《数据结构与算法分析（机械工业出版社 Mark Allen Weiss著）》\n\n\n递归算法的理解\n\n\n1.在求f(n, other variables)的时候，你就默认f(n -1, other variables)已经被求出来了——至于怎么求的，这个是计算机通过回溯求出来的。\n\n\nPS:这里用到了一种叫做栈(stack)的先进后出的数据结构，所以递归输出的答案一般是自下而上的。\n\n\n2.递归和二叉树是密切相关的。可以尝试通过二叉树的数据结构来理解递归是如何将一个问题拆分成若干子问题，求解再回溯的。这里可以参考以下快速排序(QuickSort)的过程（快速排序的核心思想是分治，分治即分而治之，通过递归将原问题分解为若干容易求解的子问题，再通过递归将这些子问题联系起来并向二叉树的上层回溯，最终求解出原问题）\n\n\n递归算法的注意\n\n\n1.递归的结束条件（不写会死循环，TLE）\n2.递归最后一层和其他有关系的层的关系怎样用非递归函数来表达\n比如：斐波纳契亚数列，（1）当n==1和n==2的时候f(n)=1，这就是递归的终止条件。给了终止条件，计算机才能进行求解子问题并回溯，最终求出f(n)\n\n"},{"url":"/2020/12/23/IPConflict/","content":"IP conflict记录一下，今天宿舍同学在使用学校的校园网时，在校园网的登录界面，出现了 IP conflict的问题，过来找我帮忙解决一下，不过之前学习的计算机网络知识基本快忘光了，只是记得模糊，于是去查了一下，特此记录。\n原因\n虽然IP地址冲突不常发生，却是一个非常实际的问题，会给用户带来极大的不便。如果两个或多个IP地址发生冲突，结果就是一个或多个计算机或设备完全无法连接网络。幸好，万一发生冲突，有些办法可以解决这个问题。之所以会发生IP地址冲突，是由于同一个网络上的两个或多个计算机或设备(比如平板电脑)最后被分配了同一个IP地址。\nIP(互联网协议)地址是计算机的唯一识别符，它由一串数字组成，比如192.168.8.4。要是没有IP地址，你就连接不上网络。通常会弹出某种警告或错误信息，提醒你注意这个问题。有时候，问题会自行解决，但并非总是如此幸运。\n通常，IP地址冲突出现在局域网上，不过也有可能出现在连接到互联网的多个设备之间。任何拥有IP地址的设备都有可能与另一个设备发生冲突。IP地址可能是静态地址，也可能是动态地址。静态IP地址从不改变，手动分配。另一方面，动态IP地址只是暂时的，每当你的计算机或设备连接到互联网或你的路由器，就分配一个新的动态IP地址。静态IP地址和动态IP地址都有可能出现冲突，不过如今静态地址出现冲突的可能性比较小，那是由于大多数路由器内置的DHCP(动态主机配置协议)服务器系统通常用来管理和分配IP地址。DHCP服务器系统有IP地址库，又叫地址范围;来自该地址库的地址被分配给设备，以响应系统对IP地址的请求IP地址冲突会因多种原因而发生，不过一个典型的例子是，两个或多个系统被分配了同样的静态IP地址。现在这种情况不常发生，这归功于DHCP服务器系统。然而，如果你有不止一个DHCP服务器在运行(你不该运行多个DHCP服务器)，配置相似的服务器就有可能将同样的地址分配给多个设备。\n\n解决\n如果你有另一个为网络连接提供便利的设备，它可能有嵌入的DHCP服务器系统，默认情况下已被开启。这种情况下，关掉服务器可以解决问题。\n互联网服务提供商(ISP)也可能为多个用户分配同一个地址。如果安装的某个设备有多个网络适配器，那么它本身就有可能遇到IP地址冲突。如果最初连接到一个网络的设备进入待机模式，随后又恢复工作，不过连接到另一个网络，而该网络上的某个设备有同一个IP地址，也会发生冲突。这可能会出现在带回家的办公笔记本电脑上，或者携带笔记本电脑或另一个设备出差时。IP地址冲突有时候完全会自行解决，但是这需要一段时间，要是果真自行解决的话。解决这个问题也许很简单，只要重启路由器即可。要是网络上的每个设备都被分配了动态IP地址，路由器重启、重新分配IP地址给网络上的每个设备后，这个问题就有望得到解决。解决这个问题的另一个办法是，通过命令提示符，释放IP地址，至少在Windows系统上可行。打开命令提示符(为此可以进入到“开始”菜单，搜索“cmd”)，然后在窗口中输入“ipconfig /release”，然后按回车键。DHCP服务器随后会为你的计算机分配一个新的IP地址。\n\n//查看IP地址  Windowsipconfig //ip 释放ipconfig /release \n\n如果一次过后没有解决问题，可以多释放几次，我同学的就是这个问题，同时可以注意每次释放后的IP地址，是否发生变化。\n"},{"url":"/2021/03/04/WorkNote/Repo%20%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/","content":"Repo 命令参考资料Repo 简化了跨多个代码库运行的流程，与 Git 相辅相成。请参阅源代码控制工具，了解有关 Repo 和 Git 之间关系的说明。如需详细了解 Repo，请参阅 Repo README。\n使用 Repo 需遵循的格式如下：\nrepo command options\n\n可选元素显示在方括号 [ ] 中。例如，许多命令将 project-list 作为参数。project-list 可以是一个名称列表，也可以是一个本地源代码目录的路径列表：\nrepo sync [project0 project1 ... projectn]repo sync [&#x2F;path&#x2F;to&#x2F;project0 ... &#x2F;path&#x2F;to&#x2F;projectn]\n\n帮助此页面仅重点介绍重要选项。要了解完整详情，请参阅命令行帮助。安装 Repo 后，您可以通过运行以下命令找到最新文档（开头是所有命令的摘要）：\nrepo help\n\n您可以通过在 Repo 树中运行以下命令来查看有关某个命令的详细信息：\nrepo help command\n\n例如，以下命令会生成 Repo init 参数的说明和选项列表，该参数会在当前目录中初始化 Repo。（如需了解详情，请参阅 init。）\nrepo help init\n\n如果您仅想查看可用选项的列表，请运行：\nrepo command --help\n\n例如：\nrepo init --help\n\ninitrepo init -u url [options]\n\n在当前目录中安装 Repo。这样会创建一个 .repo/ 目录，其中包含存放 Repo 源代码和标准 Android 清单文件的 Git 代码库。\n选项：\n\n-u：指定从中检索清单代码库的网址。常见清单位于 https://android.googlesource.com/platform/manifest。\n-m：选择代码库中的清单文件。如果未选择清单名称，则默认为 default.xml。\n-b：指定修订版本，即特定的 manifest-branch。\n\n注意：对于所有剩余的 Repo 命令，当前的工作目录必须是 .repo/ 的父目录或该父目录的子目录。\nsyncrepo sync [project-list]\n\n下载新的更改并更新本地环境中的工作文件，基本上可以在所有 Git 代码库中完成 git fetch。如果在未使用任何参数的情况下运行 repo sync，则该命令会同步所有项目的文件。\n运行 repo sync 后，将出现以下情况：\n\n如果目标项目从未同步过，则 repo sync 相当于 git clone。远程代码库中的所有分支都会复制到本地项目目录中。\n\n如果目标项目以前同步过，则 repo sync 相当于：\ngit remote updategit rebase origin&#x2F;branch\n\n其中 branch 是本地项目目录中当前已检出的分支。如果本地分支没有在跟踪远程代码库中的分支，则项目不会发生任何同步。\n\n如果 Git rebase 操作导致合并冲突，请使用常规 Git 命令（例如 git rebase --continue）来解决冲突。\n\n\n成功运行 repo sync 后，指定项目中的代码即处于最新状态，并已与远程代码库中的代码同步。\n下面是重要选项。如需了解详情，请参阅 repo help sync：\n\n-c：仅获取服务器中的当前清单分支。\n-d：将指定项目切换回清单修订版本。如果项目当前属于某个主题分支，但临时需要清单修订版本，则此选项会有所帮助。\n-f：即使某个项目同步失败，也继续同步其他项目。\n-jthreadcount：将同步操作拆分成多个线程，以更快地完成。切勿为其他任务预留 CPU，这会使计算机超负荷运行。如需查看可用 CPU 的数量，请先运行：nproc --all\n-q：通过抑制状态消息来确保运行过程没有干扰。\n-s：同步到当前清单中的 manifest-server 元素指定的一个已知良好 build。\n\nuploadrepo upload [project-list]\n\n对于指定的项目，Repo 会将本地分支与最后一次 repo sync 时更新的远程分支进行比较。Repo 会提示您选择一个或多个尚未上传以供审核的分支。\n接下来，所选分支上的所有提交都会通过 HTTPS 连接传输到 Gerrit。您需要配置一个 HTTPS 密码以启用上传授权。如需生成新的用户名/密码对以用于 HTTPS 传输，请访问密码生成器。\n当 Gerrit 通过其服务器接收对象数据时，它会将每项提交转变成一项更改，以便审核者可以针对特定提交给出意见。如需将几项“检查点”提交合并为一项提交，请运行 git rebase -i 然后再运行 upload。\n如果在未使用任何参数的情况下运行 repo upload，则该命令会在所有项目中搜索要上传的更改。\n如需在更改上传后对其进行修改，请使用 git rebase -i 或 git commit --amend 等工具更新您的本地提交内容。修改完成之后，请执行以下操作：\n\n进行验证以确保更新后的分支是当前已检出的分支。\n\n对于相应系列中的每项提交，请在方括号内输入 Gerrit 更改 ID：\n# Replacing from branch foo[ 3021 ] 35f2596c Refactor part of GetUploadableBranches to lookup one specific...[ 2829 ] ec18b4ba Update proto client to support patch set replacments# Insert change numbers in the brackets to add a new patch set.# To create a new change record, leave the brackets empty.\n\n\n\n上传完成后，这些更改将拥有一个额外的补丁程序集。\n如果您只想上传当前已检出的 Git 分支，请使用标记 --current-branch（或简称 --cbr）。\ndiffrepo diff [project-list]\n\n使用 git diff 显示提交与工作树之间的明显更改。\ndownloadrepo download target change\n\n从审核系统中下载指定更改，并放在您项目的本地工作目录中供使用。\n例如，如需将更改 23823 下载到您的 platform/build 目录，请运行以下命令：\nrepo download platform&#x2F;build 23823\n\n运行 repo sync 会移除使用 repo download 检索到的所有提交内容。或者，您也可以使用 git checkout m/master检出远程分支。\n注意：由于全球的所有服务器均存在复制延迟，因此某项更改出现在网络上（位于 Gerrit 中）的时间与所有用户可通过 repo download 找到此项更改的时间之间存在些许的镜像延迟。\nforallrepo forall [project-list] -c command\n\n在每个项目中运行指定的 shell 命令。通过 repo forall 可使用下列额外的环境变量：\n\nREPO_PROJECT 设为了项目的唯一名称。\nREPO_PATH 是相对于客户端根目录的路径。\nREPO_REMOTE 是清单中远程系统的名称。\nREPO_LREV 是清单中修订版本的名称，已转换为本地跟踪分支。如果您需要将清单修订版本传递到某个本地运行的 Git 命令，则可使用此变量。\nREPO_RREV 是清单中修订版本的名称，与清单中显示的名称完全一致。\n\n选项：\n\n-c：要执行的命令和参数。此命令会通过 /bin/sh 进行评估，它之后的任何参数都将作为 shell 位置参数传递。\n-p：在所指定命令的输出结果之前显示项目标头。这通过以下方式实现：将管道绑定到命令的 stdin、stdout 和 sterr 流，然后通过管道将所有输出结果传输到一个单页会话中显示的连续流中。\n-v：显示该命令向 stderr 写入的消息。\n\nprunerepo prune [project-list]\n\n删减（删除）已合并的主题。\nstartrepo startbranch-name [project-list]\n\n从清单中指定的修订版本开始，创建一个新的分支进行开发。\nBRANCH_NAME 参数用于简要说明您尝试对项目进行的更改。如果您不知道，请考虑使用名称 default。\nproject-list 参数指定了将参与此主题分支的项目。\n注意：句点 (.) 是一个简写形式，用来代表当前工作目录中的项目。\nstatusrepo status [project-list]\n\n对于每个指定的项目，将工作树与临时区域（索引）以及此分支 (HEAD) 上的最近一次提交进行比较。针对这三种状态之间存在差异的每个文件，显示其摘要行。\n如需查看当前分支的状态，请运行 repo status。系统会按项目列出状态信息。对于项目中的每个文件，系统使用两个字母的代码来表示：\n在第一列中，大写字母表示临时区域与上次提交状态之间的不同之处。\n\n\n\n字母\n含义\n说明\n\n\n\n-\n没有变化\n在 HEAD 与索引中相同\n\n\nA\n已添加\n不存在于 HEAD 中，但存在于索引中\n\n\nM\n已修改\n存在于 HEAD 中，但索引中的文件已修改\n\n\nD\n已删除\n存在于 HEAD 中，但不存在于索引中\n\n\nR\n已重命名\n不存在于 HEAD 中，索引中文件的路径已更改\n\n\nC\n已复制\n不存在于 HEAD 中，复制自索引中的另一个文件\n\n\nT\n模式已更改\nHEAD 与索引中的内容相同，但模式已更改\n\n\nU\n未合并\nHEAD 与索引之间存在冲突；需要加以解决\n\n\n在第二列中，小写字母表示工作目录与索引之间的不同之处。\n\n\n\n字母\n含义\n说明\n\n\n\n-\n新/未知\n不存在于索引中，但存在于工作树中\n\n\nm\n已修改\n存在于索引中，也存在于工作树中（但已修改）\n\n\nd\n已删除\n存在于索引中，但不存在于工作树中\n\n\n"}]