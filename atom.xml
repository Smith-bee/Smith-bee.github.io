<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Smith-bee Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-10-12T06:40:08.937Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Smith-bee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2020/10/12/Git/Git%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2020/10/12/Git/Git%E4%BD%BF%E7%94%A8/</id>
    <published>2020-10-12T06:39:29.700Z</published>
    <updated>2020-10-12T06:40:08.937Z</updated>
    
    <content type="html"><![CDATA[<h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分</p><p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉</p><p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p><p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫<a href="https://github.com/">GitHub</a>的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p><p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;远程仓库&quot;&gt;&lt;a href=&quot;#远程仓库&quot; class=&quot;headerlink&quot; title=&quot;远程仓库&quot;&gt;&lt;/a&gt;远程仓库&lt;/h4&gt;&lt;p&gt;Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>typora图床</title>
    <link href="http://example.com/2020/10/08/typora%E5%9B%BE%E5%BA%8A/"/>
    <id>http://example.com/2020/10/08/typora%E5%9B%BE%E5%BA%8A/</id>
    <published>2020-10-08T06:48:18.945Z</published>
    <updated>2020-10-08T07:03:35.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        之前一直受困于typora的图床功能，本地图片只能在本地的文件里使用，上传到博客，就是辣个样子😨(不忍直视……)</p><p>​        现在终于好了，可以为所欲为，为所欲为……</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><p>图床</p><p>PicGo支持的图床</p><ul><li>SM.MS图床</li><li>腾讯云cos</li><li>微博图床</li><li>GitHub图床</li><li>七牛图床</li><li>Imgur图床</li><li>阿里云oss</li><li>又拍云图床</li><li>Gitee图床</li></ul><p><img src="https://i.loli.net/2020/10/08/we3bcS7g8fWQCFx.png" alt="image-20201008101234986"></p></li><li><p>typora</p></li></ul><p>​    确保版本在<strong>0.9.86</strong>以上</p><ul><li><p>PicGo</p><p>版本2.2.0以上，<a href="https://github.com/Molunerfinn/PicGo/releases">官网下载</a></p></li></ul><h2 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h2><p>这里介绍SM.MS图床，这是PicGo默认的图床。</p><ol><li><p>注册SM.MS图床</p><p><a href="https://sm.ms/">SM.MS官网</a></p></li><li><p>在PicGo中安装<strong>smms-user</strong>这个插件</p><p><img src="https://i.loli.net/2020/10/08/f3C46oTgQ8SOFlH.png" alt="image-20201008141055746"></p><p>安装插件，需要先安装<strong>nodejs</strong>,可参考此博客，<a href="https://smith-bee.github.io/2020/10/05/nodejs%E5%8F%8Anpm/">nodejs安装</a></p></li><li><p>在SM.MS中获取<strong>API Token</strong>，粘贴到PicGo的图床设置中</p><p><img src="https://i.loli.net/2020/10/08/TltnAWmaMG6LKzE.png" alt="image-20201008141657478"></p><p><img src="https://i.loli.net/2020/10/08/xay6Eu8BwjI7rKD.png" alt="image-20201008141900832"></p></li><li><p>在<strong>Typora</strong>的<strong>文件</strong>下选择<strong>偏好设置</strong></p><p><img src="https://i.loli.net/2020/10/08/uFOLVey7zNmjldf.png" alt="image-20201008142803179"></p><p>可参考此项设置，选择自己PicGo的安装路径，可以验证图片上传是否可行</p></li><li><p>这里推荐三种在Typora中使用图床的三种方式</p></li></ol><table><thead><tr><th align="center">方式</th><th align="center">使用</th></tr></thead><tbody><tr><td align="center">拖拽</td><td align="center">将图片直接拖入编辑区</td></tr><tr><td align="center">插入</td><td align="center">在编辑区内插入，快捷键<strong>Ctrl + Shift + I</strong></td></tr><tr><td align="center">复制粘贴</td><td align="center">粘贴后，点击上传图片即可，（小编最喜欢这种）</td></tr></tbody></table><p>注：这里用的是SM.MS图床，现在可以拥有5G的免费空间，可以申请付费，速度还可以，可以接受，小编自己很多都是截图，大小都在(300kb)内，感觉短期内足够用</p><p>下面给大家在提供另一种图床的配置，挂个链接吧，有需要的可以看一下</p><p><a href="https://www.cnblogs.com/Bianco/p/13710884.html">Gitee图床与Typora</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​        之前一直受困于typora的图床功能，本地图片只能在本地的文件里使用，上传到博客，就是辣个样子😨(不忍直视……)&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git基础</title>
    <link href="http://example.com/2020/10/08/Git/Git%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2020/10/08/Git/Git%E5%9F%BA%E7%A1%80/</id>
    <published>2020-10-07T16:00:00.000Z</published>
    <updated>2020-10-12T06:39:12.255Z</updated>
    
    <content type="html"><![CDATA[<p>内容学习自<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的Git教程</a></p><h2 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h2><h3 id="git简介"><a href="#git简介" class="headerlink" title="git简介"></a>git简介</h3><p>很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p><p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p><p>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！</p><p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。</p><p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</p><p>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。</p><p>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：</p><p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p><p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p><p>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p><h3 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h3><ul><li><p>Windows</p><p>去官网下载，选择安装路径，默认安装即可 <a href="https://git-scm.com/downloads">Git官网下载</a></p></li><li><p>Lunix</p><ul><li>通常输入<strong>git</strong>可以查看如否安装，如果没有安装，会提示你安装的命令</li><li>如果是Ubuntu或Debain可以通过<code>sudo apt-get install git</code>即可安装</li><li>如果是其他版本的Linux，可以采用去官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令安装就好了</li></ul></li><li><p>Mac</p><p>在Appstore中下载<strong>Xcode</strong>这个IDE,这是苹果系统最好的IDE，开发人员一定会下载的那种，Xcode中集成了Git，不过没有默认安装，需要运行Xcode，在Preferences中找到Downloads,选择Command Line Tools，点击install即可</p></li></ul><h3 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h3><h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><ul><li><p>选择一个合适的地方，创建一个空目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir GitHubRepository</span><br><span class="line"><span class="built_in">cd</span> GitHubRepository</span><br><span class="line"><span class="built_in">pwd</span>  <span class="comment">#显示当前目录</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/08/W92r1EGqew3SyT6.png" alt="image-20201008230909591"></p><p>注：为了避免莫名其妙的问题，建议目录(包括父目录)使用英文</p></li><li><p>通过<code>git init</code>命令把此目录变成Git管理的仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/08/85BhINku4jqKEiJ.png" alt="image-20201008231517874"></p><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p></li><li><p>把文件添加到版本库</p><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><ul><li>编写一个<code>about.txt</code>文件，内容如下</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是程序员应如是</span><br><span class="line">Git is a version control system</span><br></pre></td></tr></table></figure><ul><li>使用<code>git add</code>命令，把文件添加到仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add about.txt</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/08/s8zP2ELutMcraIY.png" alt="image-20201008233157090"></p><p>注：LF和CRLF是两种换行方式，对于这次学习Git没影响</p><ul><li>使用<code>git commit</code>命令，把文件提交到仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;This is a message about me&quot;</span></span><br><span class="line"><span class="comment"># -m 后面的是本次提交的说明信息，最好写的有意义，帮助别人了解此次改动的信息</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/08/PU1LJXAvKOHITbu.png" alt="image-20201008233942586"></p><ul><li>使用<code>git status</code>查看结果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/09/ewariCGMznRUTIX.png" alt="image-20201009225826777"></p><p>注：<code>git add &lt;file&gt;</code>可以添加多个文件，反复使用；<code>git commit -m &lt;message&gt;</code>可以一次提交多个文件</p></li></ul><h4 id="时光穿梭-版本"><a href="#时光穿梭-版本" class="headerlink" title="时光穿梭(版本)"></a>时光穿梭(版本)</h4><ul><li><p>现在模仿日常工作，要对项目进行修改，我们修改<code>about.txt</code>文件，添加如下信息</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git is a free software.</span><br></pre></td></tr></table></figure><p>再使用<code>git status</code>查看结果</p><p><img src="https://i.loli.net/2020/10/09/n1aEfhRxeHY4c6y.png" alt="image-20201009231522171"></p><p>通过<code>git status</code>命令，我们可以时刻掌握仓库当前的状态，上面的命令输出告诉我们，文件被修改了，但是还没有提交修改</p><ul><li>使用<code>git diff</code>命令查看具体修改的内容</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff about.txt</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/09/yRivnBusSALM8a1.png" alt="image-20201009231932937"></p><ul><li>再分别使用<code>git add;git commit;git status</code>命令查看状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add about.txt</span><br><span class="line">git status</span><br><span class="line"><span class="comment">#查看此时的状态</span></span><br><span class="line">git commit -m <span class="string">&quot;Add a message&quot;</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment">#再查看此时的状态</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/09/D1AgKhfBPyYMSbi.png" alt="image-20201009232618220"></p></li><li><p>版本回退</p><ul><li>使用<code>git log</code>命令查看文件的版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/09/BMzS21XyV6I7eko.png" alt="image-20201009233159944"></p><p><code>git log</code>命令显示从最近到最远的提交日志</p><p>如果嫌输出信息太多，可以加上<code>--pretty=oneline</code>参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/09/jpnB3lYwhJzRqVt.png" alt="image-20201009233545546"></p><p>需要友情提示的是，你看到的一大串类似<code>4b4258ee...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><ul><li>版本回退</li></ul><p>在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#回到上一个版本</span></span><br><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/09/ScJsaBCLZfyhgiO.png" alt="image-20201009234803996"></p><p>我们已经乘坐时光机回去了</p><ul><li>想再回来</li></ul><p>如果想要再回来，就必须知道<code>commit id</code>，如果不记得了，<strong>git</strong>提供了后悔药</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git refolg <span class="comment"># 记录你的每一次命令</span></span><br><span class="line">git reset --hard 4b4258e</span><br><span class="line">cat about.txt</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/09/ke7tpof6OKg1vqu.png" alt="image-20201009235658906"></p><p>诶嘿，我胡汉三又回来了</p><p>注：版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p></li><li><p>工作区和暂存区</p><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p><ul><li><strong>工作区</strong>(Working Directory)</li></ul><p>就是你在电脑里能看到的目录，比如我的<code>LearnMysql</code>文件夹就是一个工作区</p><ul><li><strong>版本库</strong>(Repository)</li></ul><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的<strong>暂存区</strong>，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p><img src="https://i.loli.net/2020/10/10/MAUtGPH4ocVkCTd.jpg"></p><ul><li>工作流程</li></ul><p><strong>第一步</strong>是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p><strong>第二步</strong>是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p></li><li><p>管理修改</p><p>Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><ul><li>可以用<code>git diff HEAD</code>命令查看工作区和版本库里面最新版本的区别</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD --about.txt</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/10/5B7RXo2knlVxZzf.png" alt="image-20201010173159132"></p></li><li><p>撤销修改</p><p>当你在深夜加班修改项目时，不小心在项目里添加了如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TMD,stupid boss</span><br></pre></td></tr></table></figure><p>嗯<del>，难受！这个月的奖金，嗯</del></p><ul><li>内容只在工作区，没有使用过<code>git add</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- about.txt</span><br></pre></td></tr></table></figure><p><code>git checkout -- file</code>可以丢弃工作区的修改</p><p><img src="https://i.loli.net/2020/10/10/kXSGWgtaNqFQwrm.png" alt="image-20201010175159357"></p><p><img src="https://i.loli.net/2020/10/10/CGoVZM7KTmQUL3J.png" alt="image-20201010175359286"></p><p>修改被删除了</p><p>注：<code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p><ul><li>内容在暂存区，使用了<code>git add</code>命令，没使用<code>git commit</code>命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD about.txt</span><br><span class="line"><span class="comment">#把文件从暂存区重新放回工作区</span></span><br></pre></td></tr></table></figure><p>现在修改在工作区，可以使用上面的命令将工作区的修改删除</p><p><img src="https://i.loli.net/2020/10/11/MmlPyJNQHW8ekAq.png" alt="image-20201011192247370"></p><p>嗯，奖金总算保住了</p><ul><li>如果脑子一热，使用了<code>git commit</code>命令，可以通过版本回退，回到上一个版本</li></ul><p><img src="https://i.loli.net/2020/10/11/41rY75AKc2wOujd.png" alt="image-20201011193038944"></p></li></ul><ul><li><p>删除文件</p><p>现在我们有一个没用的文件<code>test.txt</code>,想要删除，文件已经在版本库中</p><p>首先我们先删除工作区的文件，可以图形化删除也可以使用命令<code>rm &lt;file&gt;</code></p><p><img src="https://i.loli.net/2020/10/11/yhxW56c9ApJqagF.png" alt="image-20201011194236192"></p><p>现在我们有两个选择</p><ul><li>删除版本库中的文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm test.txt <span class="comment">#从版本库中删除文件</span></span><br><span class="line">git commit -m <span class="string">&quot;remove test.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以使用git add test.txt 代替git rm test.txt 效果一样</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/11/pAMRHLzkwumJUxg.png" alt="image-20201011195256022"></p><ul><li>删除了，从版本库中恢复文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#git checkout 版本库里文件的版本替换工作区里文件的版本</span></span><br><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/11/elZrCfyhOYbB56T.png" alt="image-20201011195056115"></p></li></ul><p>小提示：</p><ul><li><p>git 提交信息</p><p>查看其他人提交的修改内容或自己的历史记录的时候，提交信息是需要用到的重要资料。所以请用心填写修改内容的提交信息，以方便别人理解。<br>以下是Git的标准注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第1行：提交修改内容的摘要</span><br><span class="line">第2行：空行</span><br><span class="line">第3行以后：修改的理由</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;内容学习自&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/896043488029600&quot;&gt;廖雪峰的Git教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Git基础&quot;&gt;&lt;a href=&quot;#Git基础&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Git" scheme="http://example.com/categories/Git/"/>
    
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>nodejs及nmp</title>
    <link href="http://example.com/2020/10/05/nodejs%E5%8F%8Anpm/"/>
    <id>http://example.com/2020/10/05/nodejs%E5%8F%8Anpm/</id>
    <published>2020-10-05T13:49:18.777Z</published>
    <updated>2020-10-08T07:02:06.934Z</updated>
    
    <content type="html"><![CDATA[<p>包管理工具nmp包含在nodejs中，在安装时一并安装好了</p><h2 id="nodejs安装"><a href="#nodejs安装" class="headerlink" title="nodejs安装"></a>nodejs安装</h2><ul><li>去官网下载最新版本(<a href="https://nodejs.org/en/download/">nodejs官网</a>)</li></ul><p><img src="https://i.loli.net/2020/10/08/8OQXUVqAZ6iJy9B.png" alt="image-20201005141858439"></p><ul><li>点击安装，选择安装路径，不建议安装在c盘，其他自己选择</li></ul><p><img src="https://i.loli.net/2020/10/08/6R2HqfwsQv4znIt.png" alt="image-20201005142106551"></p><ul><li>等待安装完成即可</li><li>检查是否成功，打开cmd命令行，输入如下命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/08/RomSXsU3P5OAu1p.png" alt="image-20201005142656419"></p><p>如上图，就成功了</p><h2 id="npm的配置"><a href="#npm的配置" class="headerlink" title="npm的配置"></a>npm的配置</h2><ul><li>在nodejs安装路径下(例如：E:\nodejs)，新建两个文件夹，<code>node_cache</code>和<code>node_global</code>，在命令行输入如下命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;E:\nodejs\node_global&quot;</span><br><span class="line">npm config set cache &quot;E:\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure><ul><li>因为服务器在国外，使用npm包管理工具时速度可能会很慢，所以可以配置镜像加速</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry=http://registry.nom.taobao.org</span><br></pre></td></tr></table></figure><ul><li>可以使用如下命令查看配置信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config list</span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><ul><li>在系统变量中新增<code>NODE_PATH E:\nodejs\node_global</code></li></ul><p><img src="https://i.loli.net/2020/10/08/aAdBlWOEFxJnuVe.png" alt="image-20201005144051382"></p><ul><li>在系统变量的Path中新增<code>E:\nodejs\node_global</code></li></ul><p><img src="https://i.loli.net/2020/10/08/lXIQ4gw6tB8OJvf.png" alt="image-20201005144333105"></p><p>到此为止，相关配置全部完毕了，可以正常使用了。</p><h2 id="npm入门级命令"><a href="#npm入门级命令" class="headerlink" title="npm入门级命令"></a>npm入门级命令</h2><table><thead><tr><th align="center">命令</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">npm install appname -g</td><td align="center">安装插件</td></tr><tr><td align="center">npm uninstall appname -g</td><td align="center">卸载插件</td></tr><tr><td align="center">npm update appname -g</td><td align="center">更新插件</td></tr><tr><td align="center">npm list</td><td align="center">查看安装的插件</td></tr></tbody></table><p><code>-g</code>:表示全局，相当于配置了全局变量，建议 <code>-g</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;包管理工具nmp包含在nodejs中，在安装时一并安装好了&lt;/p&gt;
&lt;h2 id=&quot;nodejs安装&quot;&gt;&lt;a href=&quot;#nodejs安装&quot; class=&quot;headerlink&quot; title=&quot;nodejs安装&quot;&gt;&lt;/a&gt;nodejs安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;去官网</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Nginx学习</title>
    <link href="http://example.com/2020/10/05/Nginx/"/>
    <id>http://example.com/2020/10/05/Nginx/</id>
    <published>2020-10-05T13:49:18.762Z</published>
    <updated>2020-10-05T14:15:19.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx学习"><a href="#Nginx学习" class="headerlink" title="Nginx学习"></a>Nginx学习</h1><h2 id="一、集群"><a href="#一、集群" class="headerlink" title="一、集群"></a>一、集群</h2><h3 id="1、什么是集群（分布式服务器架构）"><a href="#1、什么是集群（分布式服务器架构）" class="headerlink" title="1、什么是集群（分布式服务器架构）"></a>1、什么是集群（分布式服务器架构）</h3><ul><li>集：合在一起、放在一起</li><li>群：一堆、很多</li><li>服务器架构集群：多台服务器组成的响应大并发，高数据量访问的架构体系。<ul><li>特点：<ul><li>成本高</li><li>能够降低单台服务器的压力，使流量平均分配到多台服务器</li><li>使网站服务架构更加安全稳定</li></ul></li></ul></li><li>服务器：提供某种或者多种服务（功能）的机器（计算机）<ul><li>硬件：性能较好的电脑主机</li><li>软件：实现各种服务支持的协议的软件</li></ul></li></ul><h4 id="1-1、web服务软件"><a href="#1-1、web服务软件" class="headerlink" title="1.1、web服务软件"></a>1.1、web服务软件</h4><ul><li>功能：提供http、https协议的服务器，网站网页访问的功能。</li><li>服务<ul><li>apache：老牌的服务器软件，功能多并且稳定，支持多种配置，lamp环境</li><li>nginx:（俄罗斯人开发）安装简单小巧，并发量高，正在发展中，可以做web服务器、代理（反代理）服务器、邮箱服务器，lnmp环境</li><li>国内淘宝定制版的nginx:tengine（由淘宝网发起的web服务器项目，它在nginx的基础上针对大访问量网站的需求，添加了很多高级功能和特性</li><li>IIS：微软公司，为ASP脚本使用，可以通过fast-cgi（网络接口服务）的方式使用php</li><li>lighttpd：德国开发软件，小巧，提供web服务支持，cpu占有率低，访问速度快</li></ul></li></ul><h4 id="1-2、数据库"><a href="#1-2、数据库" class="headerlink" title="1.2、数据库"></a>1.2、数据库</h4><ul><li>关系型数据库（RDBMS）<ul><li>mysql：开源，属于oracle</li><li>mariadb：mysql的一个分支，语法类似于mysql</li><li>postgresql：加州伯克利大学，学院派</li><li>oracle：大型商业数据库</li><li>sqlserver：微软数据库</li><li>DB2：IBM公司的数据库</li><li>sqllite3：手机端（iOS和安卓）使用</li></ul></li><li>非关系型数据库<ul><li>memcached</li><li>redis</li><li>mongodb</li></ul></li></ul><h4 id="1-3、负载均衡"><a href="#1-3、负载均衡" class="headerlink" title="1.3、负载均衡"></a>1.3、负载均衡</h4><p>　　负载均衡服务器，分发请求到不同的服务器，使流量平均分配。</p><p>　　服务器死机，称为宕机。</p><ul><li>硬件级别：F5，性能好，价格高</li><li>软件级别：性价比高<ul><li>lvs：Linux下分发软件</li><li>nginx：upstream功能分发</li></ul></li></ul><h4 id="1-4、资源服务器"><a href="#1-4、资源服务器" class="headerlink" title="1.4、资源服务器"></a>1.4、资源服务器</h4><p>　　资源服务器存储静态资源，css、js、图片、视频等。一般此服务器会有硬盘（ssd固态）读写快速，带宽更大。</p><h4 id="1-5、反向代理"><a href="#1-5、反向代理" class="headerlink" title="1.5、反向代理"></a>1.5、反向代理</h4><p>　　反向代理服务器具有代理请求到对应的服务器的功能，也具有缓存的功能。</p><ul><li>代理服务器：举个栗子，<em>a要访问c，但a不能访问c；b可以访问c，a可以访问c；所以a告诉b，帮忙访问c，把c的数据返回给a。</em><ul><li>正向代理：内网访问外网</li><li>反向代理：外网访问内网<ul><li>squid</li><li>varnish：高性能的开源http加速器。</li><li>nginx</li></ul></li></ul></li></ul><h4 id="1-6、高可用"><a href="#1-6、高可用" class="headerlink" title="1.6、高可用"></a>1.6、高可用</h4><p>　　高可用服务器，用来监控负载均衡服务器，如果一旦负载均衡服务器宕机，会接替负载均衡服务器的工作，继续进行网络的分发工作。<br>可以认为是负载均衡服务器的备用服务器。</p><ul><li>heartbit：心脏敲击</li><li>keeplive：保持活跃</li></ul><h4 id="1-7、缓存软件"><a href="#1-7、缓存软件" class="headerlink" title="1.7、缓存软件"></a>1.7、缓存软件</h4><ul><li>memcached</li><li>redis</li></ul><h4 id="1-8、cdn内容分发"><a href="#1-8、cdn内容分发" class="headerlink" title="1.8、cdn内容分发"></a>1.8、cdn内容分发</h4><p>　　cdn：（Content Delivery Network）内容分发网络。基本思路是尽可能避开影响速度的瓶颈和环节，通过在网络各处放置节点服务器所构成<br>的在现有的互联网基础之一的一层智能虚拟网络，cdn系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合<br>信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的<br>响应速度。</p><p><img src="../image/server.png" alt="服务器的组织架构"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nginx学习&quot;&gt;&lt;a href=&quot;#Nginx学习&quot; class=&quot;headerlink&quot; title=&quot;Nginx学习&quot;&gt;&lt;/a&gt;Nginx学习&lt;/h1&gt;&lt;h2 id=&quot;一、集群&quot;&gt;&lt;a href=&quot;#一、集群&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode刷题</title>
    <link href="http://example.com/2020/10/05/LeetcodeProblem/"/>
    <id>http://example.com/2020/10/05/LeetcodeProblem/</id>
    <published>2020-10-05T13:49:18.745Z</published>
    <updated>2020-10-05T14:15:11.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode刷题"><a href="#Leetcode刷题" class="headerlink" title="Leetcode刷题"></a>Leetcode刷题</h1><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Leetcode刷题&quot;&gt;&lt;a href=&quot;#Leetcode刷题&quot; class=&quot;headerlink&quot; title=&quot;Leetcode刷题&quot;&gt;&lt;/a&gt;Leetcode刷题&lt;/h1&gt;&lt;h3 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>notebook 主题设置</title>
    <link href="http://example.com/2020/10/05/notebook%E4%B8%BB%E9%A2%98/"/>
    <id>http://example.com/2020/10/05/notebook%E4%B8%BB%E9%A2%98/</id>
    <published>2020-10-05T13:49:18.731Z</published>
    <updated>2020-10-06T03:15:03.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><ul><li>安装jupyter主题</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade jupyterthemes</span><br></pre></td></tr></table></figure><ul><li><p>操作</p><ul><li>查看主题列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jt -l</span><br></pre></td></tr></table></figure><ul><li>更换主题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jt -t 主题名称</span><br></pre></td></tr></table></figure><ul><li>恢复默认</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jt -r</span><br></pre></td></tr></table></figure></li></ul><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul><li>字体css位置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Anaconda\Lib\site-packages\notebook\static\components\codemirror\lib\codemirror.css</span><br></pre></td></tr></table></figure><ul><li><p>字体样式</p><p>在.css 文件的前几行，可直接修改</p></li><li><p>字体大小</p><p>247行，**px</p></li><li><p>行间距(如果不合适，会非常难受)</p><p>字体大小的下面</p><p>line-height:**px</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;主题&quot;&gt;&lt;a href=&quot;#主题&quot; class=&quot;headerlink&quot; title=&quot;主题&quot;&gt;&lt;/a&gt;主题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装jupyter主题&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>json学习</title>
    <link href="http://example.com/2020/10/05/json%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2020/10/05/json%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-10-05T13:49:18.718Z</published>
    <updated>2020-10-05T14:14:58.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="json学习"><a href="#json学习" class="headerlink" title="json学习"></a>json学习</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;json学习&quot;&gt;&lt;a href=&quot;#json学习&quot; class=&quot;headerlink&quot; title=&quot;json学习&quot;&gt;&lt;/a&gt;json学习&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HBase</title>
    <link href="http://example.com/2020/10/05/HBase/"/>
    <id>http://example.com/2020/10/05/HBase/</id>
    <published>2020-10-05T13:49:18.705Z</published>
    <updated>2020-10-05T14:14:52.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><h2 id="在HBase环境下，创建student表"><a href="#在HBase环境下，创建student表" class="headerlink" title="在HBase环境下，创建student表"></a>在HBase环境下，创建student表</h2><ul><li>进入HBase</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/hbase/bin</span><br><span class="line">./hbase shell</span><br></pre></td></tr></table></figure><ul><li>创建student表</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; create &#x27;student&#x27;,&#x27;info&#x27;</span><br><span class="line">&gt; put &#x27;student&#x27;,&#x27;1&#x27;,&#x27;info:name&#x27;,&#x27;James&#x27;</span><br><span class="line">&gt; put &#x27;student&#x27;,&#x27;1&#x27;,&#x27;info:gender&#x27;,&#x27;M&#x27;</span><br><span class="line">&gt; put &#x27;student&#x27;,&#x27;1&#x27;,&#x27;info:age&#x27;,&#x27;35&#x27;</span><br><span class="line">&gt; put &#x27;student&#x27;,&#x27;2&#x27;,&#x27;info:name&#x27;,&#x27;SmithGr&#x27;</span><br><span class="line">&gt; put &#x27;student&#x27;,&#x27;2&#x27;,&#x27;info:gender&#x27;,&#x27;M&#x27;</span><br><span class="line">&gt; put &#x27;student&#x27;,&#x27;2&#x27;,&#x27;info:age&#x27;,&#x27;33&#x27;</span><br><span class="line">&gt; exit</span><br></pre></td></tr></table></figure><h2 id="读取HBase中student表"><a href="#读取HBase中student表" class="headerlink" title="读取HBase中student表"></a>读取HBase中student表</h2><ul><li>编写python文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkConf, SparkContext</span><br><span class="line">conf = SparkConf().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;ReadHBase&quot;</span>)</span><br><span class="line">sc = SparkContext(conf = conf)</span><br><span class="line">host = <span class="string">&#x27;master&#x27;</span></span><br><span class="line">table = <span class="string">&#x27;student&#x27;</span></span><br><span class="line">conf = &#123;<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>: host, <span class="string">&quot;hbase.mapreduce.inputtable&quot;</span>: table&#125;</span><br><span class="line">keyConv = <span class="string">&quot;org.apache.spark.examples.pythonconverters.ImmutableBytesWritableToStringConverter&quot;</span></span><br><span class="line">valueConv = <span class="string">&quot;org.apache.spark.examples.pythonconverters.HBaseResultToStringConverter&quot;</span></span><br><span class="line">hbase_rdd = sc.newAPIHadoopRDD(<span class="string">&quot;org.apache.hadoop.hbase.mapreduce.TableInputFormat&quot;</span>,<span class="string">&quot;org.apache.hadoop.hbase.io.ImmutableBytesWritable&quot;</span>,<span class="string">&quot;org.apache.hadoop.hbase.client.Result&quot;</span>,keyConverter=keyConv,valueConverter=valueConv,conf=conf)</span><br><span class="line">count = hbase_rdd.count()</span><br><span class="line">hbase_rdd.cache()</span><br><span class="line">output = hbase_rdd.collect()</span><br><span class="line"><span class="keyword">for</span> (k, v) <span class="keyword">in</span> output:</span><br><span class="line">        <span class="keyword">print</span> (k, v)</span><br></pre></td></tr></table></figure><ul><li>执行代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-submit examples/readhbase.py</span><br></pre></td></tr></table></figure><h2 id="向HBase写入数据"><a href="#向HBase写入数据" class="headerlink" title="向HBase写入数据"></a>向HBase写入数据</h2><ul><li>编写python文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkConf, SparkContext</span><br><span class="line">conf = SparkConf().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;ReadHBase&quot;</span>)</span><br><span class="line">sc = SparkContext(conf = conf)</span><br><span class="line">host = <span class="string">&#x27;master&#x27;</span></span><br><span class="line">table = <span class="string">&#x27;student&#x27;</span></span><br><span class="line">keyConv = <span class="string">&quot;org.apache.spark.examples.pythonconverters.StringToImmutableBytesWritableConverter&quot;</span></span><br><span class="line">valueConv = <span class="string">&quot;org.apache.spark.examples.pythonconverters.StringListToPutConverter&quot;</span></span><br><span class="line">conf = &#123;<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>: host,<span class="string">&quot;hbase.mapred.outputtable&quot;</span>: table,<span class="string">&quot;mapreduce.outputformat.class&quot;</span>: <span class="string">&quot;org.apache.hadoop.hbase.mapreduce.TableOutputFormat&quot;</span>,<span class="string">&quot;mapreduce.job.output.key.class&quot;</span>: <span class="string">&quot;org.apache.hadoop.hbase.io.ImmutableBytesWritable&quot;</span>,<span class="string">&quot;mapreduce.job.output.value.class&quot;</span>: <span class="string">&quot;org.apache.hadoop.io.Writable&quot;</span>&#125;</span><br><span class="line">rawData = [<span class="string">&#x27;3,info,name,Rongcheng&#x27;</span>,<span class="string">&#x27;3,info,gender,M&#x27;</span>,<span class="string">&#x27;3,info,age,26&#x27;</span>,<span class="string">&#x27;4,info,name,Guanhua&#x27;</span>,<span class="string">&#x27;4,info,gender,M&#x27;</span>,<span class="string">&#x27;4,info,age,27&#x27;</span>]</span><br><span class="line">sc.parallelize(rawData).map(<span class="keyword">lambda</span> x: (x[<span class="number">0</span>],x.split(<span class="string">&#x27;,&#x27;</span>))).saveAsNewAPIHadoopDataset(conf=conf,keyConverter=keyConv,valueConverter=valueConv)</span><br></pre></td></tr></table></figure><ul><li>执行代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-submit examples/writehbase.py</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HBase&quot;&gt;&lt;a href=&quot;#HBase&quot; class=&quot;headerlink&quot; title=&quot;HBase&quot;&gt;&lt;/a&gt;HBase&lt;/h1&gt;&lt;h2 id=&quot;在HBase环境下，创建student表&quot;&gt;&lt;a href=&quot;#在HBase环境下，创建student表&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker学习</title>
    <link href="http://example.com/2020/10/05/docker/"/>
    <id>http://example.com/2020/10/05/docker/</id>
    <published>2020-10-05T13:49:18.351Z</published>
    <updated>2020-10-05T14:14:21.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker学习"><a href="#Docker学习" class="headerlink" title="Docker学习"></a>Docker学习</h1><br><h2 id="1-Docker简介"><a href="#1-Docker简介" class="headerlink" title="1.Docker简介"></a>1.Docker简介</h2><h3 id="1-1-什么是虚拟化"><a href="#1-1-什么是虚拟化" class="headerlink" title="1.1 什么是虚拟化"></a>1.1 什么是虚拟化</h3><p>　　在计算机中，虚拟化（Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，<br>予以抽象、转换后呈现出来，打破实体结构间的不可分割的障碍，使用户可以比原来的组态更好的方式来应用这些资源。这些资源的<br>新虚拟部分是不受现有资源的架设方式、地域或物理组态所限制的。一般所指的虚拟化资源包括计算能力和资料存储。<br><br></p><p>　　虚拟化的技术有很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化、桌面虚拟化、服务虚拟化和虚拟机等。</p><h3 id="1-2-什么是Docker"><a href="#1-2-什么是Docker" class="headerlink" title="1.2 什么是Docker"></a>1.2 什么是Docker</h3><p>　　Docker是一个开源项目，诞生于2013年初，基于Go语言实现的。后来加入Linux基金会，遵从Apache2.0协议，项目代码在Github<br>上进行维护。</p><p>　　Docker的基础是Linux，与虚拟机不同的是，Docker只能虚拟出与宿主机相同的容器，但是占用的空间非常小，运行效率非常高。</p><h3 id="1-3-Docker的组件"><a href="#1-3-Docker的组件" class="headerlink" title="1.3 Docker的组件"></a>1.3 Docker的组件</h3><ul><li>服务器与客户端 <br><br>　　Docker是一个客户端与服务器（C/S）架构程序。客户端向服务器或守护进程发出请求，服务器或守护进程将完成工作并返回结果。</li><li>镜像与容器 <br><br>　　镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建部分”。镜像是基于联合文件系统<br>的一种层式结构，有一系列指令一步一步构建出来。<br><br>　　容器是基于镜像启动起来的，容器中可以运行一个或多个进程。镜像是Docker生命周期中的构建或是打包阶段，而容器则是启动或<br>执行阶段。容器时基于镜像启动，一旦容器启动完成后，就可以在容器中安装自己需要的软件和服务。</li><li>Registry（注册中心）<br><br>　　Docker用Registry来保存用户构建的镜像。分为公有和私有两部分，Docker公司运营公共的Registry叫做Docker Hub。用户可以<br>在Docker Hub注册账号，分享并保存自己的镜像。（Docker Hub 下在巨慢，可以构建自己的Registry）。<br></li></ul><p>　　<a href="https://hub.docker.com/">Registry Hub</a><br><br></p><h2 id="2-Docker安装与启动"><a href="#2-Docker安装与启动" class="headerlink" title="2.Docker安装与启动"></a>2.Docker安装与启动</h2><h3 id="2-1-安装Docker"><a href="#2-1-安装Docker" class="headerlink" title="2.1 安装Docker"></a>2.1 安装Docker</h3><ul><li>ubuntu 安装<ul><li>apt-get 更新 <br><br><code>sudo apt-get update</code></li><li>安装Docker <br><br><code>sudo apt-get install docker.io</code></li><li>查看版本 <br><br><code>docker -v</code></li></ul></li><li>centos 安装<ul><li>yum源更新 <br><br><code>sudo yum update</code></li><li>安装需要的软件包，yum-util提供yum-config-manager功能，另外两个是device-mapper驱动依赖的 <br><br><code>sudo yum install -y yum-utils device-mapper-presistent-data lvm2</code></li><li>设置yum源为阿里源 <br><br><code>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></li><li>安装Docker <br><br><code>sudo yum install docker-ce</code></li><li>查看版本 <br><br><code>docker -v</code></li></ul></li></ul><h3 id="2-2-设置ustc的镜像"><a href="#2-2-设置ustc的镜像" class="headerlink" title="2.2 设置ustc的镜像"></a>2.2 设置ustc的镜像</h3><p>　　ustc是老牌的Linux镜像服务提供者了，还在遥远的Ubuntu5.04版本的时候就在用。ustc的docker镜像加速器速度很快。<br>ustc docker mirror 的优势之一就是不需要注册，是真正的提供服务。</p><p>　　<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p><p>　　编辑该文件：<br></p><p>　　<code>vim /etc/docker/daemon.json</code><br>　　<br>　　在文件中添加如下内容： <br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;registry-mirrors&quot;</span>:[<span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="2-3-Docker的启动与停止"><a href="#2-3-Docker的启动与停止" class="headerlink" title="2.3 Docker的启动与停止"></a>2.3 Docker的启动与停止</h3><p><strong>systemctl</strong>命令是系统服务管理器指令</p><ul><li>启动docker <br><br><code>systemctl start docker</code></li><li>停止docker <br><br><code>systemctl stop docker</code></li><li>重启docker <br><br><code>systemctl restart docker</code></li><li>查看docker状态 <br><br><code>systemctl status docker</code></li><li>开机启动 <br><br><code>systemctl enable docker</code></li><li>查看docker概要信息 <br><br><code>docker info</code></li><li>查看docker帮助文档 <br><br><code>docker --help</code></li></ul><br><h2 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3. 常用命令"></a>3. 常用命令</h2><h3 id="3-1-镜像相关命令"><a href="#3-1-镜像相关命令" class="headerlink" title="3.1 镜像相关命令"></a>3.1 镜像相关命令</h3><ul><li>查看镜像 <br><br><code>docker images</code> <br></li></ul><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>REPOSITORY</td><td>镜像名称</td></tr><tr><td>TAG</td><td>镜像标签</td></tr><tr><td>IMAGE ID</td><td>镜像ID</td></tr><tr><td>CREATED</td><td>镜像的创建日期</td></tr><tr><td>SIZE</td><td>镜像大小</td></tr></tbody></table><ul><li>搜索镜像（需要从网络中查找需要的镜像） <br><br><code>docker search 镜像名称</code> <br></li></ul><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>NAME</td><td>仓库名称</td></tr><tr><td>DESCRIPTION</td><td>镜像描述</td></tr><tr><td>STARS</td><td>用户评价，反应一个镜像的受欢迎程度</td></tr><tr><td>OFFICIAL</td><td>是否官方</td></tr><tr><td>AUTOMATED</td><td>自动创建，表示该镜像有Docker Hub自动构建流程创建的</td></tr></tbody></table><ul><li><p>拉取镜像（从中央仓库下载到本地） <br><br><code>docker pull 镜像名称</code> <br></p><p>  例如，下载centos7镜像 <br><br>  <code>docker pull centos:7</code></p></li><li><p>删除镜像 <br><br><code>docker rmi 镜像ID</code> <br><br>  删除所有镜像 <br><br>  <code>docker rmi `docker images -q` </code>   注意`,不是’</p><br></li></ul><h3 id="3-2-容器相关命令"><a href="#3-2-容器相关命令" class="headerlink" title="3.2 容器相关命令"></a>3.2 容器相关命令</h3><ul><li>查看容器<ul><li>查看正在运行的容器 <br><br><code>docker ps</code></li><li>查看所有容器 <br><br><code>docker ps -s</code></li><li>查看最后一次运行的容器 <br><br><code>docker ps -l</code></li><li>查看停止的容器 <br><br><code>docker ps -f status=exited</code></li></ul></li><li>创建与启动容器<ul><li>创建容器命令与参数说明 <br><br><code>docker run [参数]</code></li></ul></li></ul><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-i</td><td>表示运行容器</td></tr><tr><td>-t</td><td>表示容器启动后会进入其命令行，加入这两个参数后，容器创建就能登录进去，即分配一个伪终端</td></tr><tr><td>–name</td><td>为创建的容器命名</td></tr><tr><td>-v</td><td>表示目录映射关系（前者是宿主机目录，后者是映射到宿主机的目录），可以使用多个-v做多个目录或文件映射。注意，最好做目录映射，在宿主机上做修改，然后共享到容器上</td></tr><tr><td>-d</td><td>表示创建一个守护式容器在后台运行（这样创建的容器不会自动登录容器，如果只加-i,-t两个参数，创建后就会自动进入容器</td></tr><tr><td>-p</td><td>表示端口映射，前者是宿主机端口，后者是容器内的映射端口，可以使用多个-p做多个端口映射</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker学习&quot;&gt;&lt;a href=&quot;#Docker学习&quot; class=&quot;headerlink&quot; title=&quot;Docker学习&quot;&gt;&lt;/a&gt;Docker学习&lt;/h1&gt;&lt;br&gt;

&lt;h2 id=&quot;1-Docker简介&quot;&gt;&lt;a href=&quot;#1-Docker简介&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/10/05/hello-world/"/>
    <id>http://example.com/2020/10/05/hello-world/</id>
    <published>2020-10-05T13:14:45.153Z</published>
    <updated>2020-10-05T13:14:45.153Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
