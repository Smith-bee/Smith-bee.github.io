<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Smith-bee Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-06T15:36:48.256Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Smith-bee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux（Ubuntu）修改默认python版本</title>
    <link href="http://example.com/2021/03/06/WorkNote/Linux%EF%BC%88Ubuntu%EF%BC%89%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4python%E7%89%88%E6%9C%AC/"/>
    <id>http://example.com/2021/03/06/WorkNote/Linux%EF%BC%88Ubuntu%EF%BC%89%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4python%E7%89%88%E6%9C%AC/</id>
    <published>2021-03-05T16:00:00.000Z</published>
    <updated>2021-03-06T15:36:48.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-查看python版本"><a href="#1-查看python版本" class="headerlink" title="1. 查看python版本"></a>1. 查看python版本</h2><ul><li>查看系统中有哪些python版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/bin/python*</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210306163303800.png" alt="image-20210306163303800"></p><ul><li>查看系统中默认的python版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210306163825793.png" alt="image-20210306163825793"></p><h2 id="2-用户级修改"><a href="#2-用户级修改" class="headerlink" title="2. 用户级修改"></a>2. 用户级修改</h2><p>对某个特定用户修改python版本，只需要在其home目录下创建一个alias</p><ul><li>打开该用户的<code>.bashrc</code>文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><ul><li>添加新的别名来修改默认python版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> python=<span class="string">&#x27;/usr/bin/python3.5&#x27;</span></span><br></pre></td></tr></table></figure><p>注：改成你想要修改的python版本即可</p><ul><li>重新登录或重新加载<code>.bashrc</code>文件，使操作生效</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210306181041623.png" alt="image-20210306181041623"></p><h2 id="3-系统级修改"><a href="#3-系统级修改" class="headerlink" title="3. 系统级修改"></a>3. 系统级修改</h2><h3 id="3-1-基于软链接"><a href="#3-1-基于软链接" class="headerlink" title="3.1 基于软链接"></a>3.1 基于软链接</h3><ul><li>先删除默认的python软链接</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /usr/bin/python</span><br></pre></td></tr></table></figure><ul><li>然后创建一个新的软链接指向需要的python版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/bin/python3.5 /usr/bin/python</span><br></pre></td></tr></table></figure><h3 id="3-2-基于update-alternatives"><a href="#3-2-基于update-alternatives" class="headerlink" title="3.2 基于update-alternatives"></a>3.2 基于update-alternatives</h3><p>可以使用update-alternatives来为整个系统更改python版本</p><ul><li>列出所有可用的python替代版本信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --list python</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210306204933837.png" alt="image-20210306204933837"></p><p>注：如果出现以上所示的错误信息，表示update-alternatives没有添加python的替换版本</p><ul><li>将python的替换版本添加进去</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1</span><br><span class="line"><span class="comment">#update-alternatives：使用 /usr/bin/python2.7 来在自动模式中提供 /usr/bin/python (python)</span></span><br><span class="line"></span><br><span class="line">update-alternatives --install /usr/bin/python python /usr/bin/python3.5 2</span><br><span class="line"><span class="comment">#update-alternatives：使用 /usr/bin/python3.5 来在自动模式中提供 /usr/bin/python (python)</span></span><br></pre></td></tr></table></figure><p>注：install选项使用了多个参数用于创建符号链接，最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先级的选项就会被选中。 此例子中python3.5 的优先级为2，所有它会为默认的python版本</p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210306210345852.png" alt="image-20210306210345852"></p><ul><li>现在就可以在列出的python替代版本中任意切换</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --config python</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210306225539153.png" alt="image-20210306225539153"></p><ul><li>当系统不再存在某个python替代版本时，可以将其从update-alternatives列表中删除掉</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --remove python /usr/bin/python2.7</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --list python</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210306230907356.png" alt="image-20210306230907356"></p><h2 id="4-pip错误"><a href="#4-pip错误" class="headerlink" title="4. pip错误"></a>4. pip错误</h2><p>更改python默认版本之后可能会出现错误</p><ul><li>显示pip版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip --version</span><br></pre></td></tr></table></figure><ul><li>解决办法是将pip版本更改为符合当前的python版本，对于python2或者python3</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pip  <span class="comment">#python2</span></span><br><span class="line">sudo apt-get install python3-pip  <span class="comment">#python3</span></span><br></pre></td></tr></table></figure><ul><li>安装pip之后，可能版本不是最新的，需要更新</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure><ul><li>将pip更新为10.0.0之后的版本时，库里面的函数有所变动会出现问题</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#只需要修改/usr/bin/pip和/usr/bin/pip3文件</span></span><br><span class="line">from pip import main</span><br><span class="line"><span class="comment">#修改为</span></span><br><span class="line">from pip_internal import main</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-查看python版本&quot;&gt;&lt;a href=&quot;#1-查看python版本&quot; class=&quot;headerlink&quot; title=&quot;1. 查看python版本&quot;&gt;&lt;/a&gt;1. 查看python版本&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;查看系统中有哪些python版本&lt;/li&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Repo命令</title>
    <link href="http://example.com/2021/03/04/WorkNote/Repo%20%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"/>
    <id>http://example.com/2021/03/04/WorkNote/Repo%20%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</id>
    <published>2021-03-03T16:00:00.000Z</published>
    <updated>2021-03-06T16:01:56.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Repo-命令参考资料"><a href="#Repo-命令参考资料" class="headerlink" title="Repo 命令参考资料"></a>Repo 命令参考资料</h2><p>Repo 简化了跨多个代码库运行的流程，与 Git 相辅相成。请参阅<a href="https://source.android.google.cn/setup/develop?hl=zh-cn">源代码控制工具</a>，了解有关 Repo 和 Git 之间关系的说明。如需详细了解 Repo，请参阅 <a href="https://gerrit.googlesource.com/git-repo/+/refs/heads/master/README.md">Repo README</a>。</p><p>使用 Repo 需遵循的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo command options</span><br></pre></td></tr></table></figure><p>可选元素显示在方括号 [ ] 中。例如，许多命令将 project-list 作为参数。project-list 可以是一个名称列表，也可以是一个本地源代码目录的路径列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repo sync [project0 project1 ... projectn]</span><br><span class="line">repo sync [&#x2F;path&#x2F;to&#x2F;project0 ... &#x2F;path&#x2F;to&#x2F;projectn]</span><br></pre></td></tr></table></figure><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><p>此页面仅重点介绍重要选项。要了解完整详情，请参阅命令行帮助。安装 Repo 后，您可以通过运行以下命令找到最新文档（开头是所有命令的摘要）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo help</span><br></pre></td></tr></table></figure><p>您可以通过在 Repo 树中运行以下命令来查看有关某个命令的详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo help command</span><br></pre></td></tr></table></figure><p>例如，以下命令会生成 Repo <code>init</code> 参数的说明和选项列表，该参数会在当前目录中初始化 Repo。（如需了解详情，请参阅 <a href="https://source.android.google.cn/setup/develop/repo?hl=zh-cn#init">init</a>。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo help init</span><br></pre></td></tr></table></figure><p>如果您仅想查看可用选项的列表，请运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo command --help</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init --help</span><br></pre></td></tr></table></figure><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u url [options]</span><br></pre></td></tr></table></figure><p>在当前目录中安装 Repo。这样会创建一个 <code>.repo/</code> 目录，其中包含存放 Repo 源代码和标准 Android 清单文件的 Git 代码库。</p><p>选项：</p><ul><li><code>-u</code>：指定从中检索清单代码库的网址。常见清单位于 <code>https://android.googlesource.com/platform/manifest</code>。</li><li><code>-m</code>：选择代码库中的清单文件。如果未选择清单名称，则默认为 <code>default.xml</code>。</li><li><code>-b</code>：指定修订版本，即特定的 manifest-branch。</li></ul><p><strong>注意</strong>：对于所有剩余的 Repo 命令，当前的工作目录必须是 <code>.repo/</code> 的父目录或该父目录的子目录。</p><h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync [project-list]</span><br></pre></td></tr></table></figure><p>下载新的更改并更新本地环境中的工作文件，基本上可以在所有 Git 代码库中完成 <code>git fetch</code>。如果在未使用任何参数的情况下运行 <code>repo sync</code>，则该命令会同步所有项目的文件。</p><p>运行 <code>repo sync</code> 后，将出现以下情况：</p><ul><li><p>如果目标项目从未同步过，则 <code>repo sync</code> 相当于 <code>git clone</code>。远程代码库中的所有分支都会复制到本地项目目录中。</p></li><li><p>如果目标项目以前同步过，则 <code>repo sync</code> 相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote update</span><br><span class="line">git rebase origin&#x2F;branch</span><br></pre></td></tr></table></figure><p>其中 <code>branch</code> 是本地项目目录中当前已检出的分支。如果本地分支没有在跟踪远程代码库中的分支，则项目不会发生任何同步。</p></li><li><p>如果 Git rebase 操作导致合并冲突，请使用常规 Git 命令（例如 <code>git rebase --continue</code>）来解决冲突。</p></li></ul><p>成功运行 <code>repo sync</code> 后，指定项目中的代码即处于最新状态，并已与远程代码库中的代码同步。</p><p>下面是重要选项。如需了解详情，请参阅 <code>repo help sync</code>：</p><ul><li><code>-c</code>：仅获取服务器中的当前清单分支。</li><li><code>-d</code>：将指定项目切换回清单修订版本。如果项目当前属于某个主题分支，但临时需要清单修订版本，则此选项会有所帮助。</li><li><code>-f</code>：即使某个项目同步失败，也继续同步其他项目。</li><li><code>-jthreadcount</code>：将同步操作拆分成多个线程，以更快地完成。切勿为其他任务预留 CPU，这会使计算机超负荷运行。如需查看可用 CPU 的数量，请先运行：<code>nproc --all</code></li><li><code>-q</code>：通过抑制状态消息来确保运行过程没有干扰。</li><li><code>-s</code>：同步到当前清单中的 manifest-server 元素指定的一个已知良好 build。</li></ul><h3 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo upload [project-list]</span><br></pre></td></tr></table></figure><p>对于指定的项目，Repo 会将本地分支与最后一次 repo sync 时更新的远程分支进行比较。Repo 会提示您选择一个或多个尚未上传以供审核的分支。</p><p>接下来，所选分支上的所有提交都会通过 HTTPS 连接传输到 Gerrit。您需要配置一个 HTTPS 密码以启用上传授权。如需生成新的用户名/密码对以用于 HTTPS 传输，请访问<a href="https://android-review.googlesource.com/new-password">密码生成器</a>。</p><p>当 Gerrit 通过其服务器接收对象数据时，它会将每项提交转变成一项更改，以便审核者可以针对特定提交给出意见。如需将几项“检查点”提交合并为一项提交，请运行 <code>git rebase -i</code> 然后再运行 upload。</p><p>如果在未使用任何参数的情况下运行 <code>repo upload</code>，则该命令会在所有项目中搜索要上传的更改。</p><p>如需在更改上传后对其进行修改，请使用 <code>git rebase -i</code> 或 <code>git commit --amend</code> 等工具更新您的本地提交内容。修改完成之后，请执行以下操作：</p><ul><li><p>进行验证以确保更新后的分支是当前已检出的分支。</p></li><li><p>对于相应系列中的每项提交，请在方括号内输入 Gerrit 更改 ID：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Replacing from branch foo</span><br><span class="line">[ 3021 ] 35f2596c Refactor part of GetUploadableBranches to lookup one specific...</span><br><span class="line">[ 2829 ] ec18b4ba Update proto client to support patch set replacments</span><br><span class="line"># Insert change numbers in the brackets to add a new patch set.</span><br><span class="line"># To create a new change record, leave the brackets empty.</span><br></pre></td></tr></table></figure></li></ul><p>上传完成后，这些更改将拥有一个额外的补丁程序集。</p><p>如果您只想上传当前已检出的 Git 分支，请使用标记 <code>--current-branch</code>（或简称 <code>--cbr</code>）。</p><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo diff [project-list]</span><br></pre></td></tr></table></figure><p>使用 <code>git diff</code> 显示提交与工作树之间的明显更改。</p><h3 id="download"><a href="#download" class="headerlink" title="download"></a>download</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo download target change</span><br></pre></td></tr></table></figure><p>从审核系统中下载指定更改，并放在您项目的本地工作目录中供使用。</p><p>例如，如需将<a href="https://android-review.googlesource.com/23823">更改 23823</a> 下载到您的 platform/build 目录，请运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo download platform&#x2F;build 23823</span><br></pre></td></tr></table></figure><p>运行 <code>repo sync</code> 会移除使用 <code>repo download</code> 检索到的所有提交内容。或者，您也可以使用 <code>git checkout m/master</code>检出远程分支。</p><p><strong>注意</strong>：由于全球的所有服务器均存在复制延迟，因此某项更改出现在网络上（位于 <a href="https://android-review.googlesource.com/">Gerrit</a> 中）的时间与所有用户可通过 <code>repo download</code> 找到此项更改的时间之间存在些许的镜像延迟。</p><h3 id="forall"><a href="#forall" class="headerlink" title="forall"></a>forall</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo forall [project-list] -c command</span><br></pre></td></tr></table></figure><p>在每个项目中运行指定的 shell 命令。通过 <code>repo forall</code> 可使用下列额外的环境变量：</p><ul><li><code>REPO_PROJECT</code> 设为了项目的唯一名称。</li><li><code>REPO_PATH</code> 是相对于客户端根目录的路径。</li><li><code>REPO_REMOTE</code> 是清单中远程系统的名称。</li><li><code>REPO_LREV</code> 是清单中修订版本的名称，已转换为本地跟踪分支。如果您需要将清单修订版本传递到某个本地运行的 Git 命令，则可使用此变量。</li><li><code>REPO_RREV</code> 是清单中修订版本的名称，与清单中显示的名称完全一致。</li></ul><p>选项：</p><ul><li><code>-c</code>：要执行的命令和参数。此命令会通过 <code>/bin/sh</code> 进行评估，它之后的任何参数都将作为 shell 位置参数传递。</li><li><code>-p</code>：在所指定命令的输出结果之前显示项目标头。这通过以下方式实现：将管道绑定到命令的 stdin、stdout 和 sterr 流，然后通过管道将所有输出结果传输到一个单页会话中显示的连续流中。</li><li><code>-v</code>：显示该命令向 stderr 写入的消息。</li></ul><h3 id="prune"><a href="#prune" class="headerlink" title="prune"></a>prune</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo prune [project-list]</span><br></pre></td></tr></table></figure><p>删减（删除）已合并的主题。</p><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repo start</span><br><span class="line">branch-name [project-list]</span><br></pre></td></tr></table></figure><p>从清单中指定的修订版本开始，创建一个新的分支进行开发。</p><p><code>BRANCH_NAME</code> 参数用于简要说明您尝试对项目进行的更改。如果您不知道，请考虑使用名称 <code>default</code>。</p><p><code>project-list</code> 参数指定了将参与此主题分支的项目。</p><p><strong>注意</strong>：句点 (.) 是一个简写形式，用来代表当前工作目录中的项目。</p><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo status [project-list]</span><br></pre></td></tr></table></figure><p>对于每个指定的项目，将工作树与临时区域（索引）以及此分支 (HEAD) 上的最近一次提交进行比较。针对这三种状态之间存在差异的每个文件，显示其摘要行。</p><p>如需查看当前分支的状态，请运行 <code>repo status</code>。系统会按项目列出状态信息。对于项目中的每个文件，系统使用两个字母的代码来表示：</p><p>在第一列中，大写字母表示临时区域与上次提交状态之间的不同之处。</p><table><thead><tr><th align="left">字母</th><th align="left">含义</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-</td><td align="left">没有变化</td><td align="left">在 HEAD 与索引中相同</td></tr><tr><td align="left">A</td><td align="left">已添加</td><td align="left">不存在于 HEAD 中，但存在于索引中</td></tr><tr><td align="left">M</td><td align="left">已修改</td><td align="left">存在于 HEAD 中，但索引中的文件已修改</td></tr><tr><td align="left">D</td><td align="left">已删除</td><td align="left">存在于 HEAD 中，但不存在于索引中</td></tr><tr><td align="left">R</td><td align="left">已重命名</td><td align="left">不存在于 HEAD 中，索引中文件的路径已更改</td></tr><tr><td align="left">C</td><td align="left">已复制</td><td align="left">不存在于 HEAD 中，复制自索引中的另一个文件</td></tr><tr><td align="left">T</td><td align="left">模式已更改</td><td align="left">HEAD 与索引中的内容相同，但模式已更改</td></tr><tr><td align="left">U</td><td align="left">未合并</td><td align="left">HEAD 与索引之间存在冲突；需要加以解决</td></tr></tbody></table><p>在第二列中，小写字母表示工作目录与索引之间的不同之处。</p><table><thead><tr><th align="left">字母</th><th align="left">含义</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-</td><td align="left">新/未知</td><td align="left">不存在于索引中，但存在于工作树中</td></tr><tr><td align="left">m</td><td align="left">已修改</td><td align="left">存在于索引中，也存在于工作树中（但已修改）</td></tr><tr><td align="left">d</td><td align="left">已删除</td><td align="left">存在于索引中，但不存在于工作树中</td></tr></tbody></table><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>当你新建项目文件夹，想要在里面进行repo init操作的时候，有时候会出现下面这种错误：</p><blockquote><p>error: in <code>init -u ssh://...</code>: [Errno 2] No such file or directory: ‘~…/.repo/manifests/.git/HEAD’<br> error: manifest missing or unreadable – please run init</p></blockquote><p>你心想mmb，我就想执行<code>repo init</code>操作，你还让我在此之前<code>please run init</code>，拿我开心么？</p><p>骚年莫方，原来，当执行命令<code>repo init</code>后如果获取文件失败，会在<code>.repo</code>目录下生成一个<code>manifests.git</code>文件。</p><p>如果该文件存在，再次运行 <code>repo init</code>就会报这个错误。</p><p>知道原因了吧？怎么解决呢？</p><p>对！简单粗暴地把这个<code>manifests.git</code>文件夹删除！</p><p>再次<code>repo init</code>，一切OK！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Repo-命令参考资料&quot;&gt;&lt;a href=&quot;#Repo-命令参考资料&quot; class=&quot;headerlink&quot; title=&quot;Repo 命令参考资料&quot;&gt;&lt;/a&gt;Repo 命令参考资料&lt;/h2&gt;&lt;p&gt;Repo 简化了跨多个代码库运行的流程，与 Git 相辅相成。请参阅</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://example.com/2021/03/04/WorkNote/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2021/03/04/WorkNote/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-03-03T16:00:00.000Z</published>
    <updated>2021-03-04T15:49:44.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h1><h2 id="01-常用的RPM软件包命令"><a href="#01-常用的RPM软件包命令" class="headerlink" title="01. 常用的RPM软件包命令"></a>01. 常用的RPM软件包命令</h2><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">rpm -ivh filename.rpm</td><td align="center">安装软件</td></tr><tr><td align="center">rpm -Uvh filename.rpm</td><td align="center">升级软件</td></tr><tr><td align="center">rpm -e filename.rpm</td><td align="center">卸载软件</td></tr><tr><td align="center">rmp -qpi filename.rpm</td><td align="center">查看软件的描述信息</td></tr><tr><td align="center">rmp -qpl filename.rpm</td><td align="center">列出软件的文件信息</td></tr><tr><td align="center">rpm -qf filename</td><td align="center">查询文件属于哪个RPM</td></tr></tbody></table><h2 id="02-包管理工具apt-get常用命令"><a href="#02-包管理工具apt-get常用命令" class="headerlink" title="02. 包管理工具apt-get常用命令"></a>02. 包管理工具apt-get常用命令</h2><p>apt : Advanced Package Tool</p><p>一般使用这个命令时，需要权限，前面加上 sudo</p><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">sudo apt-get update</td><td align="center">更新本地包数据库列表</td></tr><tr><td align="center">sudo apt-get upgrade</td><td align="center">仅升级已安装的软件包</td></tr><tr><td align="center">sudo apt-get dist-upgrade</td><td align="center">可添加或删除程序包，以满足新的依赖</td></tr><tr><td align="center">apt-cache search 搜索内容</td><td align="center">查找/搜索软件包</td></tr><tr><td align="center">apt-cache show 包名</td><td align="center">查看某个软件包的信息</td></tr><tr><td align="center">dpkg -s 包名</td><td align="center">显示包的当前安装状态</td></tr></tbody></table><ul><li>从软件仓库安装包</li></ul><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">sudo apt-get install 包名</td><td align="center">安装软件包</td></tr><tr><td align="center">sudo apt-get install 包1 包2 ……</td><td align="center">安装所有列出的包</td></tr><tr><td align="center">sudo apt-get install -y 包名</td><td align="center">无需提示直接安装</td></tr></tbody></table><ul><li>从本地文件系统直接安装包</li></ul><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">sudo dpkg -i 包名.deb</td><td align="center">从本地系统直接安装包</td></tr></tbody></table><ul><li>移除已安装的包</li></ul><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">sudo apt-get remove 包名</td><td align="center">移除已安装的包</td></tr><tr><td align="center">sudo apt-get autoremove</td><td align="center">自动移除已知不需要的包</td></tr></tbody></table><h2 id="03-服务管理工具systemctl常用命令"><a href="#03-服务管理工具systemctl常用命令" class="headerlink" title="03. 服务管理工具systemctl常用命令"></a>03. 服务管理工具systemctl常用命令</h2><ul><li>管理服务</li></ul><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">systemctl start foo.service</td><td align="center">启动服务</td></tr><tr><td align="center">systemctl restart foo.service</td><td align="center">重启服务</td></tr><tr><td align="center">systemctl stop foo.service</td><td align="center">停止服务</td></tr><tr><td align="center">systemctl reload foo.service</td><td align="center">重新加载配置文件（不终止服务）</td></tr><tr><td align="center">systemctl status foo.service</td><td align="center">查看服务状态</td></tr></tbody></table><ul><li>设置开机启动信息</li></ul><table><thead><tr><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">systemctl enable foo.service</td><td align="center">开机自动启动</td></tr><tr><td align="center">systemctl disable foo.service</td><td align="center">开机不自动启动</td></tr><tr><td align="center">systemctl is-enabled foo.service</td><td align="center">查看特定服务是否为开机自动启动</td></tr><tr><td align="center">systemctl list-unit-files –type=service</td><td align="center">查看各个级别下服务的启动与禁止情况</td></tr></tbody></table><p>注：.service 后缀可以省略</p><h2 id="04-帮助命令man常用信息"><a href="#04-帮助命令man常用信息" class="headerlink" title="04. 帮助命令man常用信息"></a>04. 帮助命令man常用信息</h2><ul><li>man命令中常用按键以及用途</li></ul><table><thead><tr><th align="center">按键</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">空格键</td><td align="center">向下翻一页</td></tr><tr><td align="center">PaGe down</td><td align="center">向下翻一页</td></tr><tr><td align="center">PaGe up</td><td align="center">向上翻一页</td></tr><tr><td align="center">home</td><td align="center">直接前往首页</td></tr><tr><td align="center">end</td><td align="center">直接前往尾页</td></tr><tr><td align="center">/</td><td align="center">从上至下搜索某个关键词，如 /linux</td></tr><tr><td align="center">?</td><td align="center">从下至上搜索某个关键词，如 ?linux</td></tr><tr><td align="center">n</td><td align="center">定位到下一个搜索到的关键词</td></tr><tr><td align="center">N</td><td align="center">定位到上一个搜索到的关键词</td></tr><tr><td align="center">q</td><td align="center">退出帮助文档</td></tr></tbody></table><ul><li>man命令帮助信息的结构以及意义</li></ul><table><thead><tr><th align="center">结构名称</th><th align="center">代表意义</th></tr></thead><tbody><tr><td align="center">NAME</td><td align="center">命令的名称</td></tr><tr><td align="center">SYNOPSIS</td><td align="center">参数的大致使用方法</td></tr><tr><td align="center">DESCRIPTION</td><td align="center">介绍说明</td></tr><tr><td align="center">EXAMPLES</td><td align="center">演示（附带简单说明）</td></tr><tr><td align="center">OVERVIEW</td><td align="center">概述</td></tr><tr><td align="center">DEFAULTS</td><td align="center">默认的功能</td></tr><tr><td align="center">OPTIONS</td><td align="center">具体的可用选项（带介绍）</td></tr><tr><td align="center">ENVIRONMENT</td><td align="center">环境变量</td></tr><tr><td align="center">FILES</td><td align="center">用到的文件</td></tr><tr><td align="center">SEE ALSO</td><td align="center">相关的资料</td></tr><tr><td align="center">HISTORY</td><td align="center">维护历史与联系方式</td></tr></tbody></table><h2 id="05-常用系统工作命令"><a href="#05-常用系统工作命令" class="headerlink" title="05. 常用系统工作命令"></a>05. 常用系统工作命令</h2><ul><li>echo 命令</li></ul><p>用途：在终端输出字符串或变量提取后的值</p><p>格式：<code>echo [字符串|$变量]</code></p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210301214130039.png" alt="image-20210301214130039"></p><ul><li>date 命令</li></ul><p>用途：显示及设置系统的时间或日期</p><p>格式：<code>date [选项] [+指定的格式]</code></p><table><thead><tr><th align="center">参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">%t</td><td align="center">跳格[Tab键]</td></tr><tr><td align="center">%H</td><td align="center">小时（00~23）</td></tr><tr><td align="center">%I（大写i）</td><td align="center">小时（00~12）</td></tr><tr><td align="center">%M</td><td align="center">分钟（00~59）</td></tr><tr><td align="center">%S</td><td align="center">秒（00~59）</td></tr><tr><td align="center">%j</td><td align="center">今年中的第几天</td></tr></tbody></table><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210301234705625.png" alt="image-20210301234705625"></p><ul><li>reboot命令</li></ul><p>用途：重启系统</p><p>格式：<code>reboot [选项]</code> 需要管理员权限，sudo</p><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">w</td><td align="center">仅作模拟重启系统，只有记录，不会真重启</td></tr><tr><td align="center">f</td><td align="center">强制重启</td></tr></tbody></table><ul><li>poweroff命令</li></ul><p>用途：关闭系统</p><p>格式：<code>poweroff</code>  需要管理员权限，sudo</p><ul><li>wget命令</li></ul><p>用途：在终端中下载网络文件</p><p>格式：<code>wget [参数] 下载地址</code></p><table><thead><tr><th align="center">参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-b</td><td align="center">后台下载模式</td></tr><tr><td align="center">-P</td><td align="center">下载到指定目录</td></tr><tr><td align="center">-t</td><td align="center">最大尝试次数</td></tr><tr><td align="center">-c</td><td align="center">断点续传</td></tr><tr><td align="center">-p</td><td align="center">下载页面内所有资源，包括图片、视频等</td></tr><tr><td align="center">-r</td><td align="center">递归下载</td></tr></tbody></table><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210302124019187.png" alt="image-20210302124019187"></p><ul><li>ps命令</li></ul><p>用途：查看系统中的进程状态（通常结合管道使用）</p><p>格式：<code>ps [参数]</code></p><table><thead><tr><th align="center">参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">显示所有进程（包括其他用户的进程）</td></tr><tr><td align="center">-u</td><td align="center">用户以及其他详细信息</td></tr><tr><td align="center">-x</td><td align="center">显示没有控制终端的进程</td></tr></tbody></table><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210302125933828.png" alt="image-20210302125933828"></p><ul><li>top命令</li></ul><p>用途：动态地监视进程活动与系统负载等信息（相当于强化版的Windows任务管理器）</p><p>格式：<code>top</code></p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210302130629626.png" alt="image-20210302130629626"></p><p>前五行为系统整体的统计信息，其代表的含义如下：</p><p>1）第1行：系统时间、运行时间、登陆终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）</p><p>2）第2行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数</p><p>3）第3行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等</p><p>4）第4行：物理内存总量、内存空闲量、内存使用量、作为内核缓存的内存量</p><p>5）第5行：虚拟内存总量、虚拟内存空闲量、虚拟内存使用量、已被提前加载的内存量</p><ul><li>pidof命令</li></ul><p>用途：查询某个指定服务进程的PID值（每个进程的进程号码值PID是唯一的，因此可以通过PID来区分不同的进程）</p><p>格式：<code>pidof [参数] [服务名称]</code></p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210302151819375.png" alt="image-20210302151819375"></p><ul><li>kill命令</li></ul><p>用途：终止某个指定PID的服务进程</p><p>格式：<code>kill [参数] [进程PID]</code></p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210302153107250.png" alt="image-20210302153107250"></p><ul><li>killall命令</li></ul><p>用途：终止某个指定名称的服务所对应的全部进程</p><p>格式：<code>killall [参数] [进程名称]</code></p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210302153815357.png" alt="image-20210302153815357"></p><h2 id="06-系统状态检测命令"><a href="#06-系统状态检测命令" class="headerlink" title="06. 系统状态检测命令"></a>06. 系统状态检测命令</h2><ul><li>ifconfig命令</li></ul><p>用途：获取网卡配置与网络状态等信息</p><p>格式：<code>ifconfig [网络设备] [参数]</code></p><p>注：主要查看的是网卡名称、inet参数后面的IP地址、ether参数后面的网卡物理地址（MAC地址）以及RX、TX的接收数据包与发送数据包的个数及累计流量等</p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210302155450083.png" alt="image-20210302155450083"></p><ul><li>uname命令</li></ul><p>用途：查看系统内核与系统版本等信息</p><p>格式：<code>uname [-a]</code></p><p>注：一般会固定搭配上<code>-a</code>参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。</p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210302160033145.png" alt="image-20210302160033145"></p><p>如果要查看当前系统版本的详细信息，则需要查看相关文件</p><p>1）RedHat    ：  redhat-release</p><p>2）Ubuntu    ：  lsb-release</p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210302225316902.png" alt="image-20210302225316902"></p><ul><li>uptime命令</li></ul><p>用途：查看系统的负载信息</p><p>格式：<code>uptime</code></p><p>注：显示的信息为 当前系统时间、系统已运行时间、启用终端数量、平均负载值（最近1分钟、5分钟、15分钟）等信息</p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210302225928680.png" alt="image-20210302225928680"></p><ul><li>free命令</li></ul><p>用途：显示当前系统中内存的使用量信息</p><p>格式：<code>free [-h]</code></p><p>-h参数以更人性化的方式输出当前内存的实时使用量信息</p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210302230320981.png" alt="image-20210302230320981"></p><ul><li>who命令</li></ul><p>用途：查看当前登入主机的用户终端信息</p><p>格式：<code>who [参数]</code></p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210302230516173.png" alt="image-20210302230516173"></p><ul><li>last命令</li></ul><p>用途：查看所有系统的登录记录</p><p>格式：<code>last [参数]</code></p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210302230725884.png" alt="image-20210302230725884"></p><ul><li>history命令</li></ul><p>用途：显示历史执行过的命令</p><p>格式：<code>history [-c]</code></p><p>注：-c 参数会清空所有的命令历史记录</p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210302231011872.png" alt="image-20210302231011872"></p><p>注：默认显示1000条记录，可以自定义 /etc/profile 文件中 HISTSIZE 的变量值，历史命令会保存在用户家目录中的 .bash_history 文件中</p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20210302231434403.png" alt="image-20210302231434403"></p><ul><li>sosreport命令</li></ul><p>用途：收集系统配置及架构信息并输出诊断文档</p><p>格式：<code>sosreport</code></p><p>注：当Linux系统出现故障时，可以使用此命令将信息收集，会生成文档和校验码，发送给技术支持人员即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-常用命令&quot;&gt;&lt;a href=&quot;#Linux-常用命令&quot; class=&quot;headerlink&quot; title=&quot;Linux 常用命令&quot;&gt;&lt;/a&gt;Linux 常用命令&lt;/h1&gt;&lt;h2 id=&quot;01-常用的RPM软件包命令&quot;&gt;&lt;a href=&quot;#01-常用的R</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>IP conflict</title>
    <link href="http://example.com/2020/12/23/IPConflict/"/>
    <id>http://example.com/2020/12/23/IPConflict/</id>
    <published>2020-12-22T16:00:00.000Z</published>
    <updated>2021-03-04T15:23:30.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IP-conflict"><a href="#IP-conflict" class="headerlink" title="IP conflict"></a>IP conflict</h2><p>记录一下，今天宿舍同学在使用学校的校园网时，在校园网的登录界面，出现了 <strong>IP conflict</strong>的问题，过来找我帮忙解决一下，不过之前学习的计算机网络知识基本快忘光了，只是记得模糊，于是去查了一下，特此记录。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li>虽然IP地址冲突不常发生，却是一个非常实际的问题，会给用户带来极大的不便。如果两个或多个IP地址发生冲突，结果就是一个或多个计算机或设备完全无法连接网络。幸好，万一发生冲突，有些办法可以解决这个问题。之所以会发生IP地址冲突，是由于同一个网络上的两个或多个计算机或设备(比如平板电脑)最后被分配了同一个IP地址。</li><li>IP(互联网协议)地址是计算机的唯一识别符，它由一串数字组成，比如192.168.8.4。要是没有IP地址，你就连接不上网络。通常会弹出某种警告或错误信息，提醒你注意这个问题。有时候，问题会自行解决，但并非总是如此幸运。</li><li>通常，IP地址冲突出现在局域网上，不过也有可能出现在连接到互联网的多个设备之间。任何拥有IP地址的设备都有可能与另一个设备发生冲突。IP地址可能是静态地址，也可能是动态地址。静态IP地址从不改变，手动分配。另一方面，动态IP地址只是暂时的，每当你的计算机或设备连接到互联网或你的路由器，就分配一个新的动态IP地址。<br>静态IP地址和动态IP地址都有可能出现冲突，不过如今静态地址出现冲突的可能性比较小，那是由于大多数路由器内置的DHCP(动态主机配置协议)服务器系统通常用来管理和分配IP地址。DHCP服务器系统有IP地址库，又叫地址范围;来自该地址库的地址被分配给设备，以响应系统对IP地址的请求IP地址冲突会因多种原因而发生，不过一个典型的例子是，两个或多个系统被分配了同样的静态IP地址。现在这种情况不常发生，这归功于DHCP服务器系统。然而，如果你有不止一个DHCP服务器在运行(你不该运行多个DHCP服务器)，配置相似的服务器就有可能将同样的地址分配给多个设备。</li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>如果你有另一个为网络连接提供便利的设备，它可能有嵌入的DHCP服务器系统，默认情况下已被开启。这种情况下，关掉服务器可以解决问题。</li><li>互联网服务提供商(ISP)也可能为多个用户分配同一个地址。如果安装的某个设备有多个网络适配器，那么它本身就有可能遇到IP地址冲突。如果最初连接到一个网络的设备进入待机模式，随后又恢复工作，不过连接到另一个网络，而该网络上的某个设备有同一个IP地址，也会发生冲突。这可能会出现在带回家的办公笔记本电脑上，或者携带笔记本电脑或另一个设备出差时。IP地址冲突有时候完全会自行解决，但是这需要一段时间，要是果真自行解决的话。解决这个问题也许很简单，只要重启路由器即可。要是网络上的每个设备都被分配了动态IP地址，路由器重启、重新分配IP地址给网络上的每个设备后，这个问题就有望得到解决。<br>解决这个问题的另一个办法是，通过命令提示符，释放IP地址，至少在Windows系统上可行。打开命令提示符(为此可以进入到“开始”菜单，搜索“cmd”)，然后在窗口中输入“ipconfig /release”，然后按回车键。DHCP服务器随后会为你的计算机分配一个新的IP地址。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查看IP地址  Windows</span><br><span class="line">ipconfig </span><br><span class="line">//ip 释放</span><br><span class="line">ipconfig /release </span><br></pre></td></tr></table></figure><p>如果一次过后没有解决问题，可以多释放几次，我同学的就是这个问题，同时可以注意每次释放后的IP地址，是否发生变化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IP-conflict&quot;&gt;&lt;a href=&quot;#IP-conflict&quot; class=&quot;headerlink&quot; title=&quot;IP conflict&quot;&gt;&lt;/a&gt;IP conflict&lt;/h2&gt;&lt;p&gt;记录一下，今天宿舍同学在使用学校的校园网时，在校园网的登录界面，出现</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>汉诺塔问题</title>
    <link href="http://example.com/2020/11/12/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/11/12/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-11T16:00:00.000Z</published>
    <updated>2020-11-13T03:12:20.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="汉诺塔问题介绍"><a href="#汉诺塔问题介绍" class="headerlink" title="汉诺塔问题介绍"></a>汉诺塔问题介绍</h2><p>汉诺塔问题是一个经典的问题。汉诺塔（Hanoi Tower），又称河内塔，源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。</p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20201112130124165.png" alt="image-20201112130124165"></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这里我们只考虑最常用的解法，递归方法，把所有的圆盘n分为两个部分：</p><ul><li>上层的n-1个圆盘</li><li>最下层的第n个圆盘</li></ul><p>解题步骤：</p><blockquote><p>1、</p><p>​        把n-1个圆盘，从a移动到b</p><p>​        把第n个圆盘，从a移动到c</p><p>2、</p><p>​        把n-1个圆盘，从b移动到c</p></blockquote><p>n-1个圆盘的移动又会用相同的解题步骤来解决，直到一个圆盘为止</p><h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><ul><li>c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanno</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> a[],<span class="keyword">char</span> b[],<span class="keyword">char</span> c[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;圆盘从%s移动到%s\n&quot;</span>,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        hanno(n - <span class="number">1</span>,a,c,b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;圆盘从%s移动到%s\n&quot;</span>,a,c);</span><br><span class="line">        hanno(n - <span class="number">1</span>,b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    hanno(<span class="number">3</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20201113110615041.png" alt="image-20201113110615041"></p><ul><li>java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smithbee.day07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HannoTower</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        hannoo(<span class="number">3</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hannoo</span><span class="params">(<span class="keyword">int</span> n,String a,String b,String c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(a + <span class="string">&quot;移动到&quot;</span> + c);<span class="comment">//问题的最基础的解决方式，也是递归算法结束的条件</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            hannoo(n - <span class="number">1</span>,a,c,b);<span class="comment">//步骤一，将n-1个圆盘从a移动到b</span></span><br><span class="line">            System.out.println(a + <span class="string">&quot;移动到&quot;</span> + c);<span class="comment">//步骤一，将第n个圆盘从a移动到c</span></span><br><span class="line">            hannoo(n - <span class="number">1</span>,b,a,c);<span class="comment">//步骤二，将n-1个圆盘从b移动到c</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20201112135922522.png" alt="image-20201112135922522"></p><ul><li>python </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#汉诺塔问题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanno</span>(<span class="params">n,a,b,c</span>):</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">&#x27;圆盘从&#123;0&#125;移动到&#123;1&#125;&#x27;</span>.format(a,c))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hanno(n - <span class="number">1</span>,a,c,b)</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">&#x27;圆盘从&#123;0&#125;移动到&#123;1&#125;&#x27;</span>.format(a,c))</span><br><span class="line">        hanno(n - <span class="number">1</span>,b,a,c)</span><br><span class="line">        </span><br><span class="line">hanno(<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20201112140003370.png" alt="image-20201112140003370"></p><ul><li>c++</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanno</span><span class="params">(<span class="keyword">int</span> n,<span class="built_in">string</span> a,<span class="built_in">string</span> b,<span class="built_in">string</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    hanno(<span class="number">3</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanno</span><span class="params">(<span class="keyword">int</span> n,<span class="built_in">string</span> a,<span class="built_in">string</span> b,<span class="built_in">string</span> c)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;圆盘从&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;移动到&quot;</span> &lt;&lt; c &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        hanno(n - <span class="number">1</span>,a,c,b);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;圆盘从&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;移动到&quot;</span> &lt;&lt; c &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        hanno(n - <span class="number">1</span>,b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20201112141556314.png" alt="image-20201112141556314"></p><ul><li>go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hanno</span><span class="params">(n <span class="keyword">int</span>,a <span class="keyword">string</span>,b <span class="keyword">string</span>,c <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;圆盘从%s移动到%s\n&quot;</span>,a,c)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">hanno(n - <span class="number">1</span>,a,c,b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;圆盘从%s移动到%s\n&quot;</span>,a,c)</span><br><span class="line">hanno(n - <span class="number">1</span>,b,a,c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hanno(<span class="number">3</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://gitee.com/smithbee/image_bed/raw/master/image-20201112144604382.png" alt="image-20201112144604382"></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li>递归算法的四条基本准则</li></ul><blockquote><p>1.基准情形。必须有某些基准情形，它无需递归就能解出。<br>2.不断推进。对于那些需要递归求解的情形，每一次递归调用都必须要使求解的状况朝接近基准情形的方向推进。<br>3.设计法则。假设所有的递归调用都能运行。<br>4.合成效益法则。在求解同一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作<br>——-摘自《数据结构与算法分析（机械工业出版社 Mark Allen Weiss著）》</p></blockquote><ul><li>递归算法的理解</li></ul><blockquote><p>1.在求f(n, other variables)的时候，你就默认f(n -1, other variables)已经被求出来了——至于怎么求的，这个是计算机通过回溯求出来的。</p></blockquote><blockquote><p>PS:这里用到了一种叫做栈(stack)的先进后出的数据结构，所以递归输出的答案一般是自下而上的。</p></blockquote><blockquote><p>2.递归和二叉树是密切相关的。可以尝试通过二叉树的数据结构来理解递归是如何将一个问题拆分成若干子问题，求解再回溯的。这里可以参考以下快速排序(QuickSort)的过程（快速排序的核心思想是分治，分治即分而治之，通过递归将原问题分解为若干容易求解的子问题，再通过递归将这些子问题联系起来并向二叉树的上层回溯，最终求解出原问题）</p></blockquote><ul><li>递归算法的注意</li></ul><blockquote><p>1.递归的结束条件（不写会死循环，TLE）</p><p>2.递归最后一层和其他有关系的层的关系怎样用非递归函数来表达</p><p>比如：斐波纳契亚数列，（1）当n==1和n==2的时候f(n)=1，这就是递归的终止条件。给了终止条件，计算机才能进行求解子问题并回溯，最终求出f(n)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;汉诺塔问题介绍&quot;&gt;&lt;a href=&quot;#汉诺塔问题介绍&quot; class=&quot;headerlink&quot; title=&quot;汉诺塔问题介绍&quot;&gt;&lt;/a&gt;汉诺塔问题介绍&lt;/h2&gt;&lt;p&gt;汉诺塔问题是一个经典的问题。汉诺塔（Hanoi Tower），又称河内塔，源于印度一个古老传说。大梵</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>语言对比</title>
    <link href="http://example.com/2020/10/25/%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94/"/>
    <id>http://example.com/2020/10/25/%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94/</id>
    <published>2020-10-24T16:00:00.000Z</published>
    <updated>2020-11-01T02:12:55.894Z</updated>
    
    <content type="html"><![CDATA[<p>主要列出几个流行的编程语言的基础语法，用于比较和记忆，防止记忆混乱</p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">C</td><td align="center">C++</td><td align="center">Java</td><td align="center">Python</td><td align="center">Go</td></tr></tbody></table><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li>C</li></ul><ol><li>单行注释</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是C的单行注释</span></span><br></pre></td></tr></table></figure><ol start="2"><li>多行注释</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这是</span></span><br><span class="line"><span class="comment">C语言的</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><ol><li>单行注释</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是C++的单行注释</span></span><br></pre></td></tr></table></figure><ol start="2"><li>多行注释</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是</span></span><br><span class="line"><span class="comment">C++的</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>Java</li></ul><ol><li>单行注释</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是java的单行注释</span></span><br></pre></td></tr></table></figure><ol start="2"><li>多行注释</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是</span></span><br><span class="line"><span class="comment">java的</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="3"><li>文档注释</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这是java的文档注释</span></span><br><span class="line"><span class="comment">也能注释多行内容，一般用在类、方法和变量上面，用来描述其作用。注释后，鼠标放在类和变量上面会自动显示出我们注释的内容。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>Python</li></ul><ol><li>单行注释</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这是python的单行注释</span></span><br></pre></td></tr></table></figure><ol start="2"><li>多行注释</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是</span></span><br><span class="line"><span class="string">python的</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这也是</span></span><br><span class="line"><span class="string">python的</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li>Go</li></ul><ol><li>单行注释</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个是Go的单行注释</span></span><br></pre></td></tr></table></figure><ol start="2"><li>多行注释</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这个是</span></span><br><span class="line"><span class="comment">Go语言的</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>C</li><li>C++</li></ul><ol><li>整数类型</li></ol><table><thead><tr><th align="center">数据类型</th><th align="center">占用空间</th></tr></thead><tbody><tr><td align="center">short</td><td align="center">2字节</td></tr><tr><td align="center">int</td><td align="center">4字节</td></tr><tr><td align="center">long</td><td align="center">Windows为4字节；Linux为4字节(32位)、8字节(64位)</td></tr><tr><td align="center">long long</td><td align="center">8字节</td></tr></tbody></table><ol start="2"><li>实数类型(浮点型)</li></ol><table><thead><tr><th align="center"><strong>数据类型</strong></th><th align="center"><strong>占用空间</strong></th><th align="center"><strong>有效数字范围</strong></th></tr></thead><tbody><tr><td align="center">float</td><td align="center">4字节</td><td align="center">7位有效数字</td></tr><tr><td align="center">double</td><td align="center">8字节</td><td align="center">15～16位有效数字</td></tr></tbody></table><ol start="3"><li>字符型</li></ol><table><thead><tr><th align="center">数据类型</th><th align="center">占用空间</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1字节</td></tr></tbody></table><ol start="4"><li>字符串</li></ol><table><thead><tr><th align="center">数据类型</th><th align="center">头文件</th></tr></thead><tbody><tr><td align="center">string</td><td align="center">#include<string></td></tr></tbody></table><ol start="5"><li>布尔类型</li></ol><table><thead><tr><th align="center">数据类型</th><th align="center">占用空间</th><th align="center">值</th></tr></thead><tbody><tr><td align="center">bool</td><td align="center">1字节</td><td align="center">true/false</td></tr></tbody></table><ol start="6"><li>转义字符</li></ol><table><thead><tr><th align="center">转义字符</th><th align="center"><strong>含义</strong></th><th align="center"><strong>ASCII</strong>码值（十进制）</th></tr></thead><tbody><tr><td align="center">\a</td><td align="center">警报</td><td align="center">007</td></tr><tr><td align="center">\b</td><td align="center">退格(BS) ，将当前位置移到前一列</td><td align="center">008</td></tr><tr><td align="center">\f</td><td align="center">换页(FF)，将当前位置移到下页开头</td><td align="center">012</td></tr><tr><td align="center"><strong>\n</strong></td><td align="center"><strong>换行(LF) ，将当前位置移到下一行开头</strong></td><td align="center"><strong>010</strong></td></tr><tr><td align="center">\r</td><td align="center">回车(CR) ，将当前位置移到本行开头</td><td align="center">013</td></tr><tr><td align="center"><strong>\t</strong></td><td align="center"><strong>水平制表(HT)  （跳到下一个TAB位置）</strong></td><td align="center"><strong>009</strong></td></tr><tr><td align="center">\v</td><td align="center">垂直制表(VT)</td><td align="center">011</td></tr><tr><td align="center"><strong>\\</strong></td><td align="center"><strong>代表一个反斜线字符”&quot;</strong></td><td align="center"><strong>092</strong></td></tr><tr><td align="center">&#39;</td><td align="center">代表一个单引号（撇号）字符</td><td align="center">039</td></tr><tr><td align="center">&quot;</td><td align="center">代表一个双引号字符</td><td align="center">034</td></tr><tr><td align="center">?</td><td align="center">代表一个问号</td><td align="center">063</td></tr><tr><td align="center">\0</td><td align="center">数字0</td><td align="center">000</td></tr><tr><td align="center">\ddd</td><td align="center">8进制转义字符，d范围0~7</td><td align="center">3位8进制</td></tr><tr><td align="center">\xhh</td><td align="center">16进制转义字符，h范围0<del>9，a</del>f，A~F</td><td align="center">3位16进制</td></tr></tbody></table><ul><li>Java</li><li>Python</li></ul><ol><li><p>简单数据类型</p><ul><li>整型<code>&lt;class &#39;int&#39;&gt;</code></li><li>浮点型<code>&lt;class &#39;float&#39;&gt;</code></li><li>布尔型<code>&lt;class &#39;bool&#39;&gt;</code></li></ul></li><li><p>容器数据类型</p><ul><li>列表<code>&lt;class &#39;list&#39;&gt;</code></li><li>元组<code>&lt;class &#39;tuple&#39;&gt;</code></li><li>字典<code>&lt;class &#39;dict&#39;&gt;</code></li><li>集合<code>&lt;class &#39;set&#39;&gt;</code></li><li>字符串<code>&lt;class &#39;str&#39;&gt;</code></li></ul></li></ol><ul><li>Go</li></ul><h3 id="程序流程结构"><a href="#程序流程结构" class="headerlink" title="程序流程结构"></a>程序流程结构</h3><ul><li>C</li><li>C++</li></ul><ul><li>Java</li><li>Python</li><li>Go</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要列出几个流行的编程语言的基础语法，用于比较和记忆，防止记忆混乱&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
&lt;th</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>解决Permission to xxx denied to xxx问题</title>
    <link href="http://example.com/2020/10/18/Git/Permission/"/>
    <id>http://example.com/2020/10/18/Git/Permission/</id>
    <published>2020-10-17T16:00:00.000Z</published>
    <updated>2020-10-18T15:40:54.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h2><p>公司有一台电脑，使用了多个账户的ssh，今天新建一个github账号的时候，想要上传到远程仓库却出现一个问题提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Permission to xxx（远程仓库） denied to xxx(电脑上的账号)1</span><br></pre></td></tr></table></figure><p>大致意思是远程仓库的权限不被电脑上的github账号及其ssh秘钥所认可。</p><h2 id="新建ssh"><a href="#新建ssh" class="headerlink" title="新建ssh"></a>新建ssh</h2><p>想一想，这是当然的了，新建的github账号在这个电脑上又没有设定ssh，于是我去新建了一个ssh：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;XXXXXXXX&quot;1</span><br></pre></td></tr></table></figure><p>然后terminate会提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (&#x2F;Users&#x2F;zhengrunming&#x2F;.ssh&#x2F;id_rsa): 1</span><br></pre></td></tr></table></figure><p>这里由于id_rsa这个ssh文件的名字已经被我们之前账号所占用了，所以我们随便取一个其他的名字：n</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):1</span><br></pre></td></tr></table></figure><p>输入passphrase，我这直接回车</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter same passphrase again:1</span><br></pre></td></tr></table></figure><p>再次确认。</p><hr><h3 id="同步github上的ssh"><a href="#同步github上的ssh" class="headerlink" title="同步github上的ssh"></a>同步github上的ssh</h3><p>好啦，现在找到.ssh文件夹（就在用户目录下隐藏），打开文件夹可以看到新的ssh已经生成，n（私钥）和n.pub(公钥)</p><p>那么我们使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat n.pub1</span><br></pre></td></tr></table></figure><p>打开公钥，把里面的内容拷贝到github新建账户中的ssh key中（详见廖雪峰git教程的远程仓库那一节）</p><p>这样第一步就完成了，本机上的ssh key已经于github账户互通</p><hr><h3 id="查询资料"><a href="#查询资料" class="headerlink" title="查询资料"></a>查询资料</h3><p>再次尝试git push，可是还是提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Permission to xxx（远程仓库） denied to xxx(电脑上的账号)1</span><br></pre></td></tr></table></figure><p>这就蛋疼了，问题还是没有解决。</p><p>上网查询资料，原来是github虽然有了你的一个pub key，但是电脑上有两个ssh，其中一个才是你自己私用的，那么github就蒙了，不知道哪一个才是你新账户的ssh，这个时候就需要我们手动配置一下啦。<br>参考：<br><a href="https://www.jianshu.com/p/12badb7e6c10">https://www.jianshu.com/p/12badb7e6c10</a></p><hr><h3 id="配置ssh文件夹中的config"><a href="#配置ssh文件夹中的config" class="headerlink" title="配置ssh文件夹中的config"></a>配置ssh文件夹中的config</h3><p>我们打开ssh文件夹，创建config文件,如果有就不用啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim config1</span><br></pre></td></tr></table></figure><p>配置一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#Default GitHub</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line"></span><br><span class="line">#new github</span><br><span class="line">Host github-boreas6</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;n1234567891011</span><br></pre></td></tr></table></figure><p>这里可以清楚的看到，上面一大段是github默认的配置，也就是之前具有id_rsa账号的配置。那么我们需要仿照着新配置一个，告诉github拥有n这个ssh的账号是哪个就可以了,也就是这一段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#new github</span><br><span class="line">Host github-boreas6&#x2F;&#x2F;修改这里</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile ~&#x2F;.ssh&#x2F;n&#x2F;&#x2F;修改这里12345</span><br></pre></td></tr></table></figure><p>修改一下host的内容，加以辨别即可。</p><hr><h3 id="配置远程地址"><a href="#配置远程地址" class="headerlink" title="配置远程地址"></a>配置远程地址</h3><p>再回到项目，重新配置一下远程：<br>首先看一看之前的Host地址是什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v1</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  git@github.com:Boreas6&#x2F;word-collection.git (fetch)</span><br><span class="line">origin  git@github.com:Boreas6&#x2F;word-collection.git (push)12</span><br></pre></td></tr></table></figure><p>我们这里仿照一下，把<a href="mailto:&#x67;&#105;&#x74;&#64;&#103;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#105;&#x74;&#64;&#103;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;</a>这个默认的host名称改成我们之前新设定的就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin  github-boreas6:Boreas6&#x2F;word-collection.git1</span><br></pre></td></tr></table></figure><p>再看一下有没有改成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v1</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  github-boreas6:Boreas6&#x2F;word-collection.git (fetch)</span><br><span class="line">origin  github-boreas6:Boreas6&#x2F;word-collection.git (push)12</span><br></pre></td></tr></table></figure><p>修改成功！</p><hr><h3 id="重新提交"><a href="#重新提交" class="headerlink" title="重新提交"></a>重新提交</h3><p>再试试提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push 1</span><br></pre></td></tr></table></figure><p>成功了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，关键点有：</p><ol><li><p>新建一个ssh</p></li><li><p>配置config，增加新的host配置上面创建的ssh</p><p>使用remote set-url 配置host地址</p></li></ol><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><ul><li>如果是之前账户确认不用的场景，直接删除ssh文件中的内容，再新建一个ssh更快哦</li><li>使用以下代码配置新账号的用户名和邮箱</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;你的另一个用户名&quot;</span><br><span class="line">git config user.email &quot;你的另一个邮箱&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题场景&quot;&gt;&lt;a href=&quot;#问题场景&quot; class=&quot;headerlink&quot; title=&quot;问题场景&quot;&gt;&lt;/a&gt;问题场景&lt;/h2&gt;&lt;p&gt;公司有一台电脑，使用了多个账户的ssh，今天新建一个github账号的时候，想要上传到远程仓库却出现一个问题提示：&lt;/p&gt;
</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>安装MySQL(Linux)</title>
    <link href="http://example.com/2020/10/15/MySQL/%E5%AE%89%E8%A3%85MySQL/"/>
    <id>http://example.com/2020/10/15/MySQL/%E5%AE%89%E8%A3%85MySQL/</id>
    <published>2020-10-15T03:10:37.433Z</published>
    <updated>2021-03-04T15:24:57.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux环境下安装MySQL"><a href="#Linux环境下安装MySQL" class="headerlink" title="Linux环境下安装MySQL"></a>Linux环境下安装MySQL</h2><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>使用apt包管理器进行安装</p><ul><li>首先保证你的软件包是最新的，执行下面的命令更新</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><ul><li>安装mysql-server软件包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-server</span><br></pre></td></tr></table></figure><ul><li>根据提示完成安装，输入”yes”</li></ul><h3 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h3><p>正常登录会出错(由于在安装时没有设置root密码)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>下面是没有设置root密码或root密码忘记的解决办法</p><ol><li>修改<code>mysqld.cnf</code>配置文件</li></ol><p>此配置文件应该在<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code> ,使用<code>vim</code>编辑器进行修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 mysqld 块中添加下面一句</span></span><br><span class="line">skip-grant-tables <span class="comment"># 可以跳过密码直接登录</span></span><br></pre></td></tr></table></figure><p><img src="https://www.linuxidc.com/upload/2020_03/20030717497763.png" alt="Ubuntu 18.04.4 LTS上安装和使用MySQL及忘记root密码的解决"></p><p>保存退出后，需要重启MySQL服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart <span class="comment">#重启</span></span><br><span class="line">service mysql start <span class="comment">#启动</span></span><br><span class="line">service mysql status <span class="comment">#查看状态信息</span></span><br><span class="line">service mysql stop <span class="comment">#关闭</span></span><br></pre></td></tr></table></figure><p>现在就可以进入mysql了，嘻嘻</p><ol start="2"><li>设置root密码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p # 回车进入MySQL</span><br><span class="line"># 分别执行下面三句话设置密码</span><br><span class="line">use mysql; # 回车</span><br><span class="line">update user set authentication_string&#x3D;password(&quot;你的密码&quot;),plugin&#x3D;&#39;mysql_native_password&#39; where user&#x3D;&#39;root&#39;; # 回车</span><br><span class="line">flush privileges; # 回车</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在MySQL中查看下面的语句输出的信息</span><br><span class="line">select user,plugin from user;</span><br></pre></td></tr></table></figure><p><img src="https://www.linuxidc.com/upload/2020_03/temp_20030718019596.png" alt="Ubuntu 18.04.4 LTS上安装和使用MySQL及忘记root密码的解决"></p><p>这样即可！</p><ol start="3"><li>回去将第一步的配置文件在修改一下，将我们之前添加的语句注释掉(#)或删除，就可以用自己的密码登陆了，接下来就该是你的操作了，嘻嘻</li></ol><p>注：本文使用的是MySQL-5.7版本，如果是MySQL-8版本中，上面的修改密码的语句可能会出现错误，可以用下面的语句试试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER user &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;你的密码&#39;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux环境下安装MySQL&quot;&gt;&lt;a href=&quot;#Linux环境下安装MySQL&quot; class=&quot;headerlink&quot; title=&quot;Linux环境下安装MySQL&quot;&gt;&lt;/a&gt;Linux环境下安装MySQL&lt;/h2&gt;&lt;h3 id=&quot;安装MySQL&quot;&gt;&lt;a h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git小细节</title>
    <link href="http://example.com/2020/10/13/Git/Git%E5%B0%8F%E7%BB%86%E8%8A%82/"/>
    <id>http://example.com/2020/10/13/Git/Git%E5%B0%8F%E7%BB%86%E8%8A%82/</id>
    <published>2020-10-12T16:00:00.000Z</published>
    <updated>2020-10-13T11:43:13.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>Git有commit，为什么还要引入tag？</p><p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p><p>“一串乱七八糟的数字不好找！”</p><p>如果换一个办法：</p><p>“请把上周一的那个版本打包发布，版本号是v1.2”</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><ul><li>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#39;master&#39;</span><br></pre></td></tr></table></figure><p>然后，敲命令<code>git tag </code>就可以打一个新标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure><p>可以用命令<code>git tag</code>查看所有标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><ul><li>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</li></ul><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin&#x2F;master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">5dc6824 &amp; simple</span><br><span class="line">14096d0 AND simple</span><br><span class="line">b17d20e branch test</span><br><span class="line">d46f35e remove test.txt</span><br><span class="line">b84166e add test.txt</span><br><span class="line">519219b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line">1094adb append GPL</span><br><span class="line">e475afc add distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure><ul><li>再用命令<code>git tag</code>查看标签：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show </code>查看标签信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line">diff --git a&#x2F;readme.txt b&#x2F;readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p><ul><li>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure><p>用命令<code>git show </code>可以看到说明文字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 22:48:43 2018 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">diff --git a&#x2F;readme.txt b&#x2F;readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h3><ul><li>如果标签打错了，也可以删除：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag &#39;v0.1&#39; (was f15b0dd)</span><br></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin </code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao&#x2F;learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao&#x2F;learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure><ul><li>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag &#39;v0.9&#39; (was f52c633)</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs&#x2F;tags&#x2F;v0.9</span><br><span class="line">To github.com:michaelliao&#x2F;learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;标签管理&quot;&gt;&lt;a href=&quot;#标签管理&quot; class=&quot;headerlink&quot; title=&quot;标签管理&quot;&gt;&lt;/a&gt;标签管理&lt;/h2&gt;&lt;p&gt;发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的</summary>
      
    
    
    
    <category term="Git" scheme="http://example.com/categories/Git/"/>
    
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git使用</title>
    <link href="http://example.com/2020/10/12/Git/Git%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2020/10/12/Git/Git%E4%BD%BF%E7%94%A8/</id>
    <published>2020-10-11T16:00:00.000Z</published>
    <updated>2020-10-18T15:02:41.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分</p><p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉</p><p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p><p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫<a href="https://github.com/">GitHub</a>的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p><p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p><p><strong>第1步</strong>：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p><strong>第2步</strong>：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p><img src="https://i.loli.net/2020/10/12/zOwde6fJR2aCGyD.png"  /><p>点“Add Key”，你就应该看到已经添加的Key：</p><p><img src="https://i.loli.net/2020/10/12/rQRxgEfwGFPeByq.png"></p><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p><p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p><p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p><p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。</p><h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作</p><ul><li><p>在GitHub上创建一个远程库</p><p>登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</p><p><img src="https://i.loli.net/2020/10/12/LjVM7QGo9kXTJ6Z.png"></p></li><li><p>关联本地库和远程库</p><p>目前，在GitHub上的这个<code>learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:yourname/LearnMysql.git</span><br></pre></td></tr></table></figure><p><code>yourname</code>替换成你自己的GitHub用户名</p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看当前远程库的名字</span></span><br><span class="line">git remote -v </span><br><span class="line"><span class="comment">#移除一个远程库</span></span><br><span class="line">git remote remove &lt;name&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/12/4UzEFIhYrqu61xl.png" alt="image-20201012162840056"></p></li><li><p>本地库推到远程库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p><img src="https://i.loli.net/2020/10/12/i2Y7QLTg53CSOBo.png" alt="image-20201012163624273"></p><p><img src="https://i.loli.net/2020/10/12/4cdQrYIF6TiqyA7.png" alt="image-20201012163815295"></p><p>以后每次本地进行了修改，都可以推送到GitHub上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li></ul><h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><ul><li><p>克隆</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:yourname/LearnMysql.git</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/12/lyNnpUDBcmutLQh.png" alt="image-20201012165544393"></p></li></ul><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p><p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p><p><img src="https://i.loli.net/2020/10/12/3EuqblK7g5h9Jnt.png" alt="image-20201012171634774"></p><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p><p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li><p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p><p><img src="https://i.loli.net/2020/10/12/RmwT3B8OZYQpAhb.png"></p></li><li><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p><p><img src="https://i.loli.net/2020/10/12/wNrqR2avMpVLsgB.png"></p></li><li><p>Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><p><img src="https://i.loli.net/2020/10/12/7OtLBocbf1TWeCk.png"></p></li><li><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><p><img src="https://i.loli.net/2020/10/12/hvWUD7OwnfVF3jM.png"></p></li><li><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p><p><img src="https://i.loli.net/2020/10/12/PtUXYibx3TqMvOH.png"></p></li></ul><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><ul><li>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>然后，用<code>git branch</code>命令查看当前分支：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p><p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick.</span><br></pre></td></tr></table></figure><p>然后提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">&quot;branch test&quot;</span></span><br><span class="line">[dev b17d20e] branch <span class="built_in">test</span></span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure><p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p><p><img src="https://i.loli.net/2020/10/12/TztULWwrgIBlQcV.png"></p><ul><li>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p><p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p><ul><li>合并完成后，就可以放心地删除<code>dev</code>分支了：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure><p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p><ul><li>switch</li></ul><p>我们注意到切换分支使用<code>git checkout </code>，而前面讲过的撤销修改则是<code>git checkout -- </code>，同一个命令，有两种作用，确实有点令人迷惑。</p><p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p><p>创建并切换到新的<code>dev</code>分支，可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c dev</span><br></pre></td></tr></table></figure><p>直接切换到已有的<code>master</code>分支，可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git switch master</span><br></pre></td></tr></table></figure><p>使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解。</p><h3 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a>分支冲突</h3><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p><ul><li>准备新的<code>feature1</code>分支，继续我们的新分支开发：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c feature1</span><br><span class="line">Switched to a new branch <span class="string">&#x27;feature1&#x27;</span></span><br></pre></td></tr></table></figure><p>修改<code>readme.txt</code>最后一行，改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick AND simple.</span><br></pre></td></tr></table></figure><p>在<code>feature1</code>分支上提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;AND simple&quot;</span></span><br><span class="line">[feature1 14096d0] AND simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><ul><li>切换到<code>master</code>分支：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 1 commit.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br></pre></td></tr></table></figure><p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p><p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick &amp; simple.</span><br></pre></td></tr></table></figure><p>提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">&quot;&amp; simple&quot;</span></span><br><span class="line">[master 5dc6824] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p><p><img src="https://i.loli.net/2020/10/12/26gTSDLxjYmtNpX.png"></p><ul><li>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 2 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们可以直接查看readme.txt的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure><p>再提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">&quot;conflict fixed&quot;</span></span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p><p><img src="https://i.loli.net/2020/10/12/rVX8RyFJhK1mdwN.png"></p><ul><li>用带参数的<code>git log</code>也可以看到分支的合并情况：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * 14096d0 (feature1) AND simple</span><br><span class="line">* | 5dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch <span class="built_in">test</span></span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* 519219b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* 1094adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>最后，删除<code>feature1</code>分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1 (was 14096d0).</span><br></pre></td></tr></table></figure><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p><ul><li>首先，仍然创建并切换<code>dev</code>分支：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c dev</span><br><span class="line">Switched to a new branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure><p>修改readme.txt文件，并提交一个新的commit：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">&quot;add merge&quot;</span></span><br><span class="line">[dev f52c633] add merge</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><ul><li>现在，我们切换回<code>master</code>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure><p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev</span><br><span class="line">Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><ul><li>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</li></ul><p>合并后，我们用<code>git log</code>看看分支历史：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><p><img src="https://i.loli.net/2020/10/12/QCqwPma1ntoy9Wb.png" alt="image-20201012232859271"></p><h4 id="实际开发中"><a href="#实际开发中" class="headerlink" title="实际开发中"></a>实际开发中</h4><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://i.loli.net/2020/10/12/5QAgNlUuVnEMmea.png"></p><h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><ul><li>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p><ul><li>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><ul><li>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 6 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch <span class="string">&#x27;issue-101&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">&quot;fix bug 101&quot;</span></span><br><span class="line">[issue-101 4c805e2] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><ul><li>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 6 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m <span class="string">&quot;merged bug fix 101&quot;</span> issue-101</span><br><span class="line">Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br><span class="line"> readme.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><ul><li>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到<code>dev</code>分支干活了！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git switch dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><ul><li>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><ul><li><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p></li><li><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a)</span><br></pre></td></tr></table></figure><p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><ul><li>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</li></ul><p>​     那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？</p><p>​     有木有更简单的方法？</p><p>​     有！</p><ul><li><p>同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个         提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p></li><li><p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git cherry-pick 4c805e2</span><br><span class="line">[master 1d4b803] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><ul><li><p>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p></li><li><p>既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从dev分支切换到master分支。</p></li></ul><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><ul><li>于是准备开发：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c feature-vulcan</span><br><span class="line">Switched to a new branch <span class="string">&#x27;feature-vulcan&#x27;</span></span><br></pre></td></tr></table></figure><p>5分钟后，开发完毕：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git add vulcan.py</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch feature-vulcan</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">new file:   vulcan.py</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;add feature vulcan&quot;</span></span><br><span class="line">[feature-vulcan 287773e] add feature vulcan</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 vulcan.py</span><br></pre></td></tr></table></figure><p>切回<code>dev</code>，准备合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git switch dev</span><br></pre></td></tr></table></figure><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p><ul><li>但是！</li></ul><p>就在此时，接到上级命令，因经费不足，新功能必须取消！</p><p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature-vulcan</span><br><span class="line">error: The branch <span class="string">&#x27;feature-vulcan&#x27;</span> is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run <span class="string">&#x27;git branch -D feature-vulcan&#x27;</span>.</span><br></pre></td></tr></table></figure><p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code>-D</code>参数。。</p><p>现在我们强行删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D feature-vulcan</span><br><span class="line">Deleted branch feature-vulcan (was 287773e).</span><br></pre></td></tr></table></figure><p>终于删除成功！</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p><ul><li>要查看远程库的信息，用<code>git remote</code>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><ul><li>或者，用<code>git remote -v</code>显示更详细的信息：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><ul><li>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><ul><li>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？<ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul></li></ul><h4 id="拉取分支"><a href="#拉取分支" class="headerlink" title="拉取分支"></a>拉取分支</h4><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p><ul><li>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:michaelliao/learngit.git</span><br><span class="line">Cloning into <span class="string">&#x27;learngit&#x27;</span>...</span><br><span class="line">remote: Counting objects: 40, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (21/21), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0</span><br><span class="line">Receiving objects: 100% (40/40), <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (14/14), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><ul><li>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;add env&quot;</span></span><br><span class="line">[dev 7a5e5dd] add env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f52c633..7a5e5dd  dev -&gt; dev</span><br></pre></td></tr></table></figure><ul><li>小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat env.txt</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;add new env&quot;</span></span><br><span class="line">[dev 7bd91f1] add new env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">&#x27;git@github.com:michaelliao/learngit.git&#x27;</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">&#x27;git pull ...&#x27;</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">&#x27;Note about fast-forwards&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;git push --help&#x27;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><ul><li>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify <span class="built_in">which</span> branch you want to merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to <span class="built_in">set</span> tracking information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure><ul><li><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch <span class="string">&#x27;dev&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;dev&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br></pre></td></tr></table></figure><p>再pull：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict <span class="keyword">in</span> env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;fix env conflict&quot;</span></span><br><span class="line">[dev 57c53ab] fix env conflict</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin </code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin </code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to  origin/</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p>多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p><ul><li>每次合并再push后，分支变成了这样：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* d1be385 (HEAD -&gt; master, origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">| |/  </span><br><span class="line">* |   12a631b merged bug fix 101</span><br><span class="line">|\ \  </span><br><span class="line">| * | 4c805e2 fix bug 101</span><br><span class="line">|/ /  </span><br><span class="line">* |   e1e9c68 merge with no-ff</span><br><span class="line">|\ \  </span><br><span class="line">| |/  </span><br><span class="line">| * f52c633 add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure><p>总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？</p><ul><li>Git有一种称为rebase的操作，有人把它翻译成“变基”。</li></ul><p>在和远程分支同步后，我们对<code>hello.py</code>这个文件做了两次提交。用<code>git log</code>命令看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 582d922 (HEAD -&gt; master) add author</span><br><span class="line">* 8875536 add comment</span><br><span class="line">* d1be385 (origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意到Git用<code>(HEAD -&gt; master)</code>和<code>(origin/master)</code>标识出当前分支的HEAD和远程origin的位置分别是<code>582d922 add author</code>和<code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p><ul><li>现在我们尝试推送本地分支：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to <span class="string">&#x27;git@github.com:michaelliao/learngit.git&#x27;</span></span><br><span class="line">hint: Updates were rejected because the remote contains work that you <span class="keyword">do</span></span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., <span class="string">&#x27;git pull ...&#x27;</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">&#x27;Note about fast-forwards&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;git push --help&#x27;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><ul><li>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">From github.com:michaelliao/learngit</span><br><span class="line">   d1be385..f005ed4  master     -&gt; origin/master</span><br><span class="line"> * [new tag]         v1.0       -&gt; v1.0</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br><span class="line"> hello.py | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><ul><li>再用<code>git status</code>看看状态：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/master&#x27;</span> by 3 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p><ul><li>用<code>git log</code>看看：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e0ea545 (HEAD -&gt; master) Merge branch <span class="string">&#x27;master&#x27;</span> of github.com:michaelliao/learngit</span><br><span class="line">|\  </span><br><span class="line">| * f005ed4 (origin/master) <span class="built_in">set</span> <span class="built_in">exit</span>=1</span><br><span class="line">* | 582d922 add author</span><br><span class="line">* | 8875536 add comment</span><br><span class="line">|/  </span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>我们输入命令<code>git rebase</code>试试：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: add comment</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">Mhello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Applying: add author</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">Mhello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br></pre></td></tr></table></figure><p>输出了一大堆操作，到底是啥效果？再用<code>git log</code>看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 (origin/master) <span class="built_in">set</span> <span class="built_in">exit</span>=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了<code>f005ed4 (origin/master) set exit=1</code>之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于<code>d1be385 init hello</code>，而是基于<code>f005ed4 (origin/master) set exit=1</code>，但最后的提交<code>7e61ed4</code>内容是一致的。</p><ul><li>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</li></ul><p>最后，通过push操作把本地分支推送到远程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 1 <span class="built_in">local</span> object.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f005ed4..7e61ed4  master -&gt; master</span><br></pre></td></tr></table></figure><p>再用<code>git log</code>看看效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master, origin/master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 <span class="built_in">set</span> <span class="built_in">exit</span>=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>远程分支的提交历史也是一条直线。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;远程仓库&quot;&gt;&lt;a href=&quot;#远程仓库&quot; class=&quot;headerlink&quot; title=&quot;远程仓库&quot;&gt;&lt;/a&gt;远程仓库&lt;/h2&gt;&lt;p&gt;Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此</summary>
      
    
    
    
    <category term="Git" scheme="http://example.com/categories/Git/"/>
    
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>typora图床</title>
    <link href="http://example.com/2020/10/08/typora%E5%9B%BE%E5%BA%8A/"/>
    <id>http://example.com/2020/10/08/typora%E5%9B%BE%E5%BA%8A/</id>
    <published>2020-10-08T06:48:18.945Z</published>
    <updated>2020-10-08T07:03:35.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        之前一直受困于typora的图床功能，本地图片只能在本地的文件里使用，上传到博客，就是辣个样子😨(不忍直视……)</p><p>​        现在终于好了，可以为所欲为，为所欲为……</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><p>图床</p><p>PicGo支持的图床</p><ul><li>SM.MS图床</li><li>腾讯云cos</li><li>微博图床</li><li>GitHub图床</li><li>七牛图床</li><li>Imgur图床</li><li>阿里云oss</li><li>又拍云图床</li><li>Gitee图床</li></ul><p><img src="https://i.loli.net/2020/10/08/we3bcS7g8fWQCFx.png" alt="image-20201008101234986"></p></li><li><p>typora</p></li></ul><p>​    确保版本在<strong>0.9.86</strong>以上</p><ul><li><p>PicGo</p><p>版本2.2.0以上，<a href="https://github.com/Molunerfinn/PicGo/releases">官网下载</a></p></li></ul><h2 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h2><p>这里介绍SM.MS图床，这是PicGo默认的图床。</p><ol><li><p>注册SM.MS图床</p><p><a href="https://sm.ms/">SM.MS官网</a></p></li><li><p>在PicGo中安装<strong>smms-user</strong>这个插件</p><p><img src="https://i.loli.net/2020/10/08/f3C46oTgQ8SOFlH.png" alt="image-20201008141055746"></p><p>安装插件，需要先安装<strong>nodejs</strong>,可参考此博客，<a href="https://smith-bee.github.io/2020/10/05/nodejs%E5%8F%8Anpm/">nodejs安装</a></p></li><li><p>在SM.MS中获取<strong>API Token</strong>，粘贴到PicGo的图床设置中</p><p><img src="https://i.loli.net/2020/10/08/TltnAWmaMG6LKzE.png" alt="image-20201008141657478"></p><p><img src="https://i.loli.net/2020/10/08/xay6Eu8BwjI7rKD.png" alt="image-20201008141900832"></p></li><li><p>在<strong>Typora</strong>的<strong>文件</strong>下选择<strong>偏好设置</strong></p><p><img src="https://i.loli.net/2020/10/08/uFOLVey7zNmjldf.png" alt="image-20201008142803179"></p><p>可参考此项设置，选择自己PicGo的安装路径，可以验证图片上传是否可行</p></li><li><p>这里推荐三种在Typora中使用图床的三种方式</p></li></ol><table><thead><tr><th align="center">方式</th><th align="center">使用</th></tr></thead><tbody><tr><td align="center">拖拽</td><td align="center">将图片直接拖入编辑区</td></tr><tr><td align="center">插入</td><td align="center">在编辑区内插入，快捷键<strong>Ctrl + Shift + I</strong></td></tr><tr><td align="center">复制粘贴</td><td align="center">粘贴后，点击上传图片即可，（小编最喜欢这种）</td></tr></tbody></table><p>注：这里用的是SM.MS图床，现在可以拥有5G的免费空间，可以申请付费，速度还可以，可以接受，小编自己很多都是截图，大小都在(300kb)内，感觉短期内足够用</p><p>下面给大家在提供另一种图床的配置，挂个链接吧，有需要的可以看一下</p><p><a href="https://www.cnblogs.com/Bianco/p/13710884.html">Gitee图床与Typora</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​        之前一直受困于typora的图床功能，本地图片只能在本地的文件里使用，上传到博客，就是辣个样子😨(不忍直视……)&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git基础</title>
    <link href="http://example.com/2020/10/08/Git/Git%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2020/10/08/Git/Git%E5%9F%BA%E7%A1%80/</id>
    <published>2020-10-07T16:00:00.000Z</published>
    <updated>2020-10-12T15:05:32.739Z</updated>
    
    <content type="html"><![CDATA[<p>内容学习自<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的Git教程</a></p><h2 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h2><h3 id="git简介"><a href="#git简介" class="headerlink" title="git简介"></a>git简介</h3><p>很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p><p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p><p>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！</p><p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。</p><p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</p><p>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。</p><p>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：</p><p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p><p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p><p>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p><h3 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h3><ul><li><p>Windows</p><p>去官网下载，选择安装路径，默认安装即可 <a href="https://git-scm.com/downloads">Git官网下载</a></p></li><li><p>Lunix</p><ul><li>通常输入<strong>git</strong>可以查看如否安装，如果没有安装，会提示你安装的命令</li><li>如果是Ubuntu或Debain可以通过<code>sudo apt-get install git</code>即可安装</li><li>如果是其他版本的Linux，可以采用去官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令安装就好了</li></ul></li><li><p>Mac</p><p>在Appstore中下载<strong>Xcode</strong>这个IDE,这是苹果系统最好的IDE，开发人员一定会下载的那种，Xcode中集成了Git，不过没有默认安装，需要运行Xcode，在Preferences中找到Downloads,选择Command Line Tools，点击install即可</p></li></ul><h3 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h3><h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><ul><li><p>选择一个合适的地方，创建一个空目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir GitHubRepository</span><br><span class="line"><span class="built_in">cd</span> GitHubRepository</span><br><span class="line"><span class="built_in">pwd</span>  <span class="comment">#显示当前目录</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/08/W92r1EGqew3SyT6.png" alt="image-20201008230909591"></p><p>注：为了避免莫名其妙的问题，建议目录(包括父目录)使用英文</p></li><li><p>通过<code>git init</code>命令把此目录变成Git管理的仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/08/85BhINku4jqKEiJ.png" alt="image-20201008231517874"></p><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p></li><li><p>把文件添加到版本库</p><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><ul><li>编写一个<code>about.txt</code>文件，内容如下</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是程序员应如是</span><br><span class="line">Git is a version control system</span><br></pre></td></tr></table></figure><ul><li>使用<code>git add</code>命令，把文件添加到仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add about.txt</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/08/s8zP2ELutMcraIY.png" alt="image-20201008233157090"></p><p>注：LF和CRLF是两种换行方式，对于这次学习Git没影响</p><ul><li>使用<code>git commit</code>命令，把文件提交到仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;This is a message about me&quot;</span></span><br><span class="line"><span class="comment"># -m 后面的是本次提交的说明信息，最好写的有意义，帮助别人了解此次改动的信息</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/08/PU1LJXAvKOHITbu.png" alt="image-20201008233942586"></p><ul><li>使用<code>git status</code>查看结果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/09/ewariCGMznRUTIX.png" alt="image-20201009225826777"></p><p>注：<code>git add &lt;file&gt;</code>可以添加多个文件，反复使用；<code>git commit -m &lt;message&gt;</code>可以一次提交多个文件</p></li></ul><h4 id="时光穿梭-版本"><a href="#时光穿梭-版本" class="headerlink" title="时光穿梭(版本)"></a>时光穿梭(版本)</h4><ul><li><p>现在模仿日常工作，要对项目进行修改，我们修改<code>about.txt</code>文件，添加如下信息</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git is a free software.</span><br></pre></td></tr></table></figure><p>再使用<code>git status</code>查看结果</p><p><img src="https://i.loli.net/2020/10/09/n1aEfhRxeHY4c6y.png" alt="image-20201009231522171"></p><p>通过<code>git status</code>命令，我们可以时刻掌握仓库当前的状态，上面的命令输出告诉我们，文件被修改了，但是还没有提交修改</p><ul><li>使用<code>git diff</code>命令查看具体修改的内容</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff about.txt</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/09/yRivnBusSALM8a1.png" alt="image-20201009231932937"></p><ul><li>再分别使用<code>git add;git commit;git status</code>命令查看状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add about.txt</span><br><span class="line">git status</span><br><span class="line"><span class="comment">#查看此时的状态</span></span><br><span class="line">git commit -m <span class="string">&quot;Add a message&quot;</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment">#再查看此时的状态</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/09/D1AgKhfBPyYMSbi.png" alt="image-20201009232618220"></p></li><li><p>版本回退</p><ul><li>使用<code>git log</code>命令查看文件的版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/09/BMzS21XyV6I7eko.png" alt="image-20201009233159944"></p><p><code>git log</code>命令显示从最近到最远的提交日志</p><p>如果嫌输出信息太多，可以加上<code>--pretty=oneline</code>参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/09/jpnB3lYwhJzRqVt.png" alt="image-20201009233545546"></p><p>需要友情提示的是，你看到的一大串类似<code>4b4258ee...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><ul><li>版本回退</li></ul><p>在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#回到上一个版本</span></span><br><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/09/ScJsaBCLZfyhgiO.png" alt="image-20201009234803996"></p><p>我们已经乘坐时光机回去了</p><ul><li>想再回来</li></ul><p>如果想要再回来，就必须知道<code>commit id</code>，如果不记得了，<strong>git</strong>提供了后悔药</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git refolg <span class="comment"># 记录你的每一次命令</span></span><br><span class="line">git reset --hard 4b4258e</span><br><span class="line">cat about.txt</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/09/ke7tpof6OKg1vqu.png" alt="image-20201009235658906"></p><p>诶嘿，我胡汉三又回来了</p><p>注：版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p></li><li><p>工作区和暂存区</p><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p><ul><li><strong>工作区</strong>(Working Directory)</li></ul><p>就是你在电脑里能看到的目录，比如我的<code>LearnMysql</code>文件夹就是一个工作区</p><ul><li><strong>版本库</strong>(Repository)</li></ul><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的<strong>暂存区</strong>，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p><img src="https://i.loli.net/2020/10/10/MAUtGPH4ocVkCTd.jpg"></p><ul><li>工作流程</li></ul><p><strong>第一步</strong>是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p><strong>第二步</strong>是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p></li><li><p>管理修改</p><p>Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><ul><li>可以用<code>git diff HEAD</code>命令查看工作区和版本库里面最新版本的区别</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD --about.txt</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/10/5B7RXo2knlVxZzf.png" alt="image-20201010173159132"></p></li><li><p>撤销修改</p><p>当你在深夜加班修改项目时，不小心在项目里添加了如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TMD,stupid boss</span><br></pre></td></tr></table></figure><p>嗯<del>，难受！这个月的奖金，嗯</del></p><ul><li>内容只在工作区，没有使用过<code>git add</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- about.txt</span><br></pre></td></tr></table></figure><p><code>git checkout -- file</code>可以丢弃工作区的修改</p><p><img src="https://i.loli.net/2020/10/10/kXSGWgtaNqFQwrm.png" alt="image-20201010175159357"></p><p><img src="https://i.loli.net/2020/10/10/CGoVZM7KTmQUL3J.png" alt="image-20201010175359286"></p><p>修改被删除了</p><p>注：<code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p><ul><li>内容在暂存区，使用了<code>git add</code>命令，没使用<code>git commit</code>命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD about.txt</span><br><span class="line"><span class="comment">#把文件从暂存区重新放回工作区</span></span><br></pre></td></tr></table></figure><p>现在修改在工作区，可以使用上面的命令将工作区的修改删除</p><p><img src="https://i.loli.net/2020/10/11/MmlPyJNQHW8ekAq.png" alt="image-20201011192247370"></p><p>嗯，奖金总算保住了</p><ul><li>如果脑子一热，使用了<code>git commit</code>命令，可以通过版本回退，回到上一个版本</li></ul><p><img src="https://i.loli.net/2020/10/11/41rY75AKc2wOujd.png" alt="image-20201011193038944"></p></li></ul><ul><li><p>删除文件</p><p>现在我们有一个没用的文件<code>test.txt</code>,想要删除，文件已经在版本库中</p><p>首先我们先删除工作区的文件，可以图形化删除也可以使用命令<code>rm &lt;file&gt;</code></p><p><img src="https://i.loli.net/2020/10/11/yhxW56c9ApJqagF.png" alt="image-20201011194236192"></p><p>现在我们有两个选择</p><ul><li>删除版本库中的文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm test.txt <span class="comment">#从版本库中删除文件</span></span><br><span class="line">git commit -m <span class="string">&quot;remove test.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以使用git add test.txt 代替git rm test.txt 效果一样</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/11/pAMRHLzkwumJUxg.png" alt="image-20201011195256022"></p><ul><li>删除了，从版本库中恢复文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#git checkout 版本库里文件的版本替换工作区里文件的版本</span></span><br><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/11/elZrCfyhOYbB56T.png" alt="image-20201011195056115"></p></li></ul><p>小提示：</p><ul><li><p>git 提交信息</p><p>查看其他人提交的修改内容或自己的历史记录的时候，提交信息是需要用到的重要资料。所以请用心填写修改内容的提交信息，以方便别人理解。<br>以下是Git的标准注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第1行：提交修改内容的摘要</span><br><span class="line">第2行：空行</span><br><span class="line">第3行以后：修改的理由</span><br></pre></td></tr></table></figure></li><li><p>git更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">git --version</span><br><span class="line"><span class="comment">#git版本是2.17.1之前</span></span><br><span class="line">git update</span><br><span class="line"><span class="comment">#git版本是2.17.1之后</span></span><br><span class="line">git update-git-for-windows</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;内容学习自&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/896043488029600&quot;&gt;廖雪峰的Git教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Git基础&quot;&gt;&lt;a href=&quot;#Git基础&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Git" scheme="http://example.com/categories/Git/"/>
    
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>nodejs及nmp</title>
    <link href="http://example.com/2020/10/05/nodejs%E5%8F%8Anpm/"/>
    <id>http://example.com/2020/10/05/nodejs%E5%8F%8Anpm/</id>
    <published>2020-10-05T13:49:18.777Z</published>
    <updated>2020-10-08T07:02:06.934Z</updated>
    
    <content type="html"><![CDATA[<p>包管理工具nmp包含在nodejs中，在安装时一并安装好了</p><h2 id="nodejs安装"><a href="#nodejs安装" class="headerlink" title="nodejs安装"></a>nodejs安装</h2><ul><li>去官网下载最新版本(<a href="https://nodejs.org/en/download/">nodejs官网</a>)</li></ul><p><img src="https://i.loli.net/2020/10/08/8OQXUVqAZ6iJy9B.png" alt="image-20201005141858439"></p><ul><li>点击安装，选择安装路径，不建议安装在c盘，其他自己选择</li></ul><p><img src="https://i.loli.net/2020/10/08/6R2HqfwsQv4znIt.png" alt="image-20201005142106551"></p><ul><li>等待安装完成即可</li><li>检查是否成功，打开cmd命令行，输入如下命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/08/RomSXsU3P5OAu1p.png" alt="image-20201005142656419"></p><p>如上图，就成功了</p><h2 id="npm的配置"><a href="#npm的配置" class="headerlink" title="npm的配置"></a>npm的配置</h2><ul><li>在nodejs安装路径下(例如：E:\nodejs)，新建两个文件夹，<code>node_cache</code>和<code>node_global</code>，在命令行输入如下命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;E:\nodejs\node_global&quot;</span><br><span class="line">npm config set cache &quot;E:\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure><ul><li>因为服务器在国外，使用npm包管理工具时速度可能会很慢，所以可以配置镜像加速</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry=http://registry.nom.taobao.org</span><br></pre></td></tr></table></figure><ul><li>可以使用如下命令查看配置信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config list</span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><ul><li>在系统变量中新增<code>NODE_PATH E:\nodejs\node_global</code></li></ul><p><img src="https://i.loli.net/2020/10/08/aAdBlWOEFxJnuVe.png" alt="image-20201005144051382"></p><ul><li>在系统变量的Path中新增<code>E:\nodejs\node_global</code></li></ul><p><img src="https://i.loli.net/2020/10/08/lXIQ4gw6tB8OJvf.png" alt="image-20201005144333105"></p><p>到此为止，相关配置全部完毕了，可以正常使用了。</p><h2 id="npm入门级命令"><a href="#npm入门级命令" class="headerlink" title="npm入门级命令"></a>npm入门级命令</h2><table><thead><tr><th align="center">命令</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">npm install appname -g</td><td align="center">安装插件</td></tr><tr><td align="center">npm uninstall appname -g</td><td align="center">卸载插件</td></tr><tr><td align="center">npm update appname -g</td><td align="center">更新插件</td></tr><tr><td align="center">npm list</td><td align="center">查看安装的插件</td></tr></tbody></table><p><code>-g</code>:表示全局，相当于配置了全局变量，建议 <code>-g</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;包管理工具nmp包含在nodejs中，在安装时一并安装好了&lt;/p&gt;
&lt;h2 id=&quot;nodejs安装&quot;&gt;&lt;a href=&quot;#nodejs安装&quot; class=&quot;headerlink&quot; title=&quot;nodejs安装&quot;&gt;&lt;/a&gt;nodejs安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;去官网</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Nginx学习</title>
    <link href="http://example.com/2020/10/05/Nginx/"/>
    <id>http://example.com/2020/10/05/Nginx/</id>
    <published>2020-10-05T13:49:18.762Z</published>
    <updated>2020-10-05T14:15:19.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx学习"><a href="#Nginx学习" class="headerlink" title="Nginx学习"></a>Nginx学习</h1><h2 id="一、集群"><a href="#一、集群" class="headerlink" title="一、集群"></a>一、集群</h2><h3 id="1、什么是集群（分布式服务器架构）"><a href="#1、什么是集群（分布式服务器架构）" class="headerlink" title="1、什么是集群（分布式服务器架构）"></a>1、什么是集群（分布式服务器架构）</h3><ul><li>集：合在一起、放在一起</li><li>群：一堆、很多</li><li>服务器架构集群：多台服务器组成的响应大并发，高数据量访问的架构体系。<ul><li>特点：<ul><li>成本高</li><li>能够降低单台服务器的压力，使流量平均分配到多台服务器</li><li>使网站服务架构更加安全稳定</li></ul></li></ul></li><li>服务器：提供某种或者多种服务（功能）的机器（计算机）<ul><li>硬件：性能较好的电脑主机</li><li>软件：实现各种服务支持的协议的软件</li></ul></li></ul><h4 id="1-1、web服务软件"><a href="#1-1、web服务软件" class="headerlink" title="1.1、web服务软件"></a>1.1、web服务软件</h4><ul><li>功能：提供http、https协议的服务器，网站网页访问的功能。</li><li>服务<ul><li>apache：老牌的服务器软件，功能多并且稳定，支持多种配置，lamp环境</li><li>nginx:（俄罗斯人开发）安装简单小巧，并发量高，正在发展中，可以做web服务器、代理（反代理）服务器、邮箱服务器，lnmp环境</li><li>国内淘宝定制版的nginx:tengine（由淘宝网发起的web服务器项目，它在nginx的基础上针对大访问量网站的需求，添加了很多高级功能和特性</li><li>IIS：微软公司，为ASP脚本使用，可以通过fast-cgi（网络接口服务）的方式使用php</li><li>lighttpd：德国开发软件，小巧，提供web服务支持，cpu占有率低，访问速度快</li></ul></li></ul><h4 id="1-2、数据库"><a href="#1-2、数据库" class="headerlink" title="1.2、数据库"></a>1.2、数据库</h4><ul><li>关系型数据库（RDBMS）<ul><li>mysql：开源，属于oracle</li><li>mariadb：mysql的一个分支，语法类似于mysql</li><li>postgresql：加州伯克利大学，学院派</li><li>oracle：大型商业数据库</li><li>sqlserver：微软数据库</li><li>DB2：IBM公司的数据库</li><li>sqllite3：手机端（iOS和安卓）使用</li></ul></li><li>非关系型数据库<ul><li>memcached</li><li>redis</li><li>mongodb</li></ul></li></ul><h4 id="1-3、负载均衡"><a href="#1-3、负载均衡" class="headerlink" title="1.3、负载均衡"></a>1.3、负载均衡</h4><p>　　负载均衡服务器，分发请求到不同的服务器，使流量平均分配。</p><p>　　服务器死机，称为宕机。</p><ul><li>硬件级别：F5，性能好，价格高</li><li>软件级别：性价比高<ul><li>lvs：Linux下分发软件</li><li>nginx：upstream功能分发</li></ul></li></ul><h4 id="1-4、资源服务器"><a href="#1-4、资源服务器" class="headerlink" title="1.4、资源服务器"></a>1.4、资源服务器</h4><p>　　资源服务器存储静态资源，css、js、图片、视频等。一般此服务器会有硬盘（ssd固态）读写快速，带宽更大。</p><h4 id="1-5、反向代理"><a href="#1-5、反向代理" class="headerlink" title="1.5、反向代理"></a>1.5、反向代理</h4><p>　　反向代理服务器具有代理请求到对应的服务器的功能，也具有缓存的功能。</p><ul><li>代理服务器：举个栗子，<em>a要访问c，但a不能访问c；b可以访问c，a可以访问c；所以a告诉b，帮忙访问c，把c的数据返回给a。</em><ul><li>正向代理：内网访问外网</li><li>反向代理：外网访问内网<ul><li>squid</li><li>varnish：高性能的开源http加速器。</li><li>nginx</li></ul></li></ul></li></ul><h4 id="1-6、高可用"><a href="#1-6、高可用" class="headerlink" title="1.6、高可用"></a>1.6、高可用</h4><p>　　高可用服务器，用来监控负载均衡服务器，如果一旦负载均衡服务器宕机，会接替负载均衡服务器的工作，继续进行网络的分发工作。<br>可以认为是负载均衡服务器的备用服务器。</p><ul><li>heartbit：心脏敲击</li><li>keeplive：保持活跃</li></ul><h4 id="1-7、缓存软件"><a href="#1-7、缓存软件" class="headerlink" title="1.7、缓存软件"></a>1.7、缓存软件</h4><ul><li>memcached</li><li>redis</li></ul><h4 id="1-8、cdn内容分发"><a href="#1-8、cdn内容分发" class="headerlink" title="1.8、cdn内容分发"></a>1.8、cdn内容分发</h4><p>　　cdn：（Content Delivery Network）内容分发网络。基本思路是尽可能避开影响速度的瓶颈和环节，通过在网络各处放置节点服务器所构成<br>的在现有的互联网基础之一的一层智能虚拟网络，cdn系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合<br>信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的<br>响应速度。</p><p><img src="../image/server.png" alt="服务器的组织架构"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nginx学习&quot;&gt;&lt;a href=&quot;#Nginx学习&quot; class=&quot;headerlink&quot; title=&quot;Nginx学习&quot;&gt;&lt;/a&gt;Nginx学习&lt;/h1&gt;&lt;h2 id=&quot;一、集群&quot;&gt;&lt;a href=&quot;#一、集群&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode刷题</title>
    <link href="http://example.com/2020/10/05/LeetcodeProblem/"/>
    <id>http://example.com/2020/10/05/LeetcodeProblem/</id>
    <published>2020-10-05T13:49:18.745Z</published>
    <updated>2020-10-05T14:15:11.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode刷题"><a href="#Leetcode刷题" class="headerlink" title="Leetcode刷题"></a>Leetcode刷题</h1><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Leetcode刷题&quot;&gt;&lt;a href=&quot;#Leetcode刷题&quot; class=&quot;headerlink&quot; title=&quot;Leetcode刷题&quot;&gt;&lt;/a&gt;Leetcode刷题&lt;/h1&gt;&lt;h3 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>notebook 主题设置</title>
    <link href="http://example.com/2020/10/05/notebook%E4%B8%BB%E9%A2%98/"/>
    <id>http://example.com/2020/10/05/notebook%E4%B8%BB%E9%A2%98/</id>
    <published>2020-10-05T13:49:18.731Z</published>
    <updated>2020-10-06T03:15:03.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><ul><li>安装jupyter主题</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade jupyterthemes</span><br></pre></td></tr></table></figure><ul><li><p>操作</p><ul><li>查看主题列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jt -l</span><br></pre></td></tr></table></figure><ul><li>更换主题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jt -t 主题名称</span><br></pre></td></tr></table></figure><ul><li>恢复默认</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jt -r</span><br></pre></td></tr></table></figure></li></ul><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul><li>字体css位置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Anaconda\Lib\site-packages\notebook\static\components\codemirror\lib\codemirror.css</span><br></pre></td></tr></table></figure><ul><li><p>字体样式</p><p>在.css 文件的前几行，可直接修改</p></li><li><p>字体大小</p><p>247行，**px</p></li><li><p>行间距(如果不合适，会非常难受)</p><p>字体大小的下面</p><p>line-height:**px</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;主题&quot;&gt;&lt;a href=&quot;#主题&quot; class=&quot;headerlink&quot; title=&quot;主题&quot;&gt;&lt;/a&gt;主题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装jupyter主题&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>json学习</title>
    <link href="http://example.com/2020/10/05/json%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2020/10/05/json%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-10-05T13:49:18.718Z</published>
    <updated>2020-10-05T14:14:58.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="json学习"><a href="#json学习" class="headerlink" title="json学习"></a>json学习</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;json学习&quot;&gt;&lt;a href=&quot;#json学习&quot; class=&quot;headerlink&quot; title=&quot;json学习&quot;&gt;&lt;/a&gt;json学习&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HBase</title>
    <link href="http://example.com/2020/10/05/HBase/"/>
    <id>http://example.com/2020/10/05/HBase/</id>
    <published>2020-10-05T13:49:18.705Z</published>
    <updated>2020-10-05T14:14:52.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h1><h2 id="在HBase环境下，创建student表"><a href="#在HBase环境下，创建student表" class="headerlink" title="在HBase环境下，创建student表"></a>在HBase环境下，创建student表</h2><ul><li>进入HBase</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/hbase/bin</span><br><span class="line">./hbase shell</span><br></pre></td></tr></table></figure><ul><li>创建student表</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; create &#x27;student&#x27;,&#x27;info&#x27;</span><br><span class="line">&gt; put &#x27;student&#x27;,&#x27;1&#x27;,&#x27;info:name&#x27;,&#x27;James&#x27;</span><br><span class="line">&gt; put &#x27;student&#x27;,&#x27;1&#x27;,&#x27;info:gender&#x27;,&#x27;M&#x27;</span><br><span class="line">&gt; put &#x27;student&#x27;,&#x27;1&#x27;,&#x27;info:age&#x27;,&#x27;35&#x27;</span><br><span class="line">&gt; put &#x27;student&#x27;,&#x27;2&#x27;,&#x27;info:name&#x27;,&#x27;SmithGr&#x27;</span><br><span class="line">&gt; put &#x27;student&#x27;,&#x27;2&#x27;,&#x27;info:gender&#x27;,&#x27;M&#x27;</span><br><span class="line">&gt; put &#x27;student&#x27;,&#x27;2&#x27;,&#x27;info:age&#x27;,&#x27;33&#x27;</span><br><span class="line">&gt; exit</span><br></pre></td></tr></table></figure><h2 id="读取HBase中student表"><a href="#读取HBase中student表" class="headerlink" title="读取HBase中student表"></a>读取HBase中student表</h2><ul><li>编写python文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkConf, SparkContext</span><br><span class="line">conf = SparkConf().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;ReadHBase&quot;</span>)</span><br><span class="line">sc = SparkContext(conf = conf)</span><br><span class="line">host = <span class="string">&#x27;master&#x27;</span></span><br><span class="line">table = <span class="string">&#x27;student&#x27;</span></span><br><span class="line">conf = &#123;<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>: host, <span class="string">&quot;hbase.mapreduce.inputtable&quot;</span>: table&#125;</span><br><span class="line">keyConv = <span class="string">&quot;org.apache.spark.examples.pythonconverters.ImmutableBytesWritableToStringConverter&quot;</span></span><br><span class="line">valueConv = <span class="string">&quot;org.apache.spark.examples.pythonconverters.HBaseResultToStringConverter&quot;</span></span><br><span class="line">hbase_rdd = sc.newAPIHadoopRDD(<span class="string">&quot;org.apache.hadoop.hbase.mapreduce.TableInputFormat&quot;</span>,<span class="string">&quot;org.apache.hadoop.hbase.io.ImmutableBytesWritable&quot;</span>,<span class="string">&quot;org.apache.hadoop.hbase.client.Result&quot;</span>,keyConverter=keyConv,valueConverter=valueConv,conf=conf)</span><br><span class="line">count = hbase_rdd.count()</span><br><span class="line">hbase_rdd.cache()</span><br><span class="line">output = hbase_rdd.collect()</span><br><span class="line"><span class="keyword">for</span> (k, v) <span class="keyword">in</span> output:</span><br><span class="line">        <span class="keyword">print</span> (k, v)</span><br></pre></td></tr></table></figure><ul><li>执行代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-submit examples/readhbase.py</span><br></pre></td></tr></table></figure><h2 id="向HBase写入数据"><a href="#向HBase写入数据" class="headerlink" title="向HBase写入数据"></a>向HBase写入数据</h2><ul><li>编写python文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkConf, SparkContext</span><br><span class="line">conf = SparkConf().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;ReadHBase&quot;</span>)</span><br><span class="line">sc = SparkContext(conf = conf)</span><br><span class="line">host = <span class="string">&#x27;master&#x27;</span></span><br><span class="line">table = <span class="string">&#x27;student&#x27;</span></span><br><span class="line">keyConv = <span class="string">&quot;org.apache.spark.examples.pythonconverters.StringToImmutableBytesWritableConverter&quot;</span></span><br><span class="line">valueConv = <span class="string">&quot;org.apache.spark.examples.pythonconverters.StringListToPutConverter&quot;</span></span><br><span class="line">conf = &#123;<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>: host,<span class="string">&quot;hbase.mapred.outputtable&quot;</span>: table,<span class="string">&quot;mapreduce.outputformat.class&quot;</span>: <span class="string">&quot;org.apache.hadoop.hbase.mapreduce.TableOutputFormat&quot;</span>,<span class="string">&quot;mapreduce.job.output.key.class&quot;</span>: <span class="string">&quot;org.apache.hadoop.hbase.io.ImmutableBytesWritable&quot;</span>,<span class="string">&quot;mapreduce.job.output.value.class&quot;</span>: <span class="string">&quot;org.apache.hadoop.io.Writable&quot;</span>&#125;</span><br><span class="line">rawData = [<span class="string">&#x27;3,info,name,Rongcheng&#x27;</span>,<span class="string">&#x27;3,info,gender,M&#x27;</span>,<span class="string">&#x27;3,info,age,26&#x27;</span>,<span class="string">&#x27;4,info,name,Guanhua&#x27;</span>,<span class="string">&#x27;4,info,gender,M&#x27;</span>,<span class="string">&#x27;4,info,age,27&#x27;</span>]</span><br><span class="line">sc.parallelize(rawData).map(<span class="keyword">lambda</span> x: (x[<span class="number">0</span>],x.split(<span class="string">&#x27;,&#x27;</span>))).saveAsNewAPIHadoopDataset(conf=conf,keyConverter=keyConv,valueConverter=valueConv)</span><br></pre></td></tr></table></figure><ul><li>执行代码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-submit examples/writehbase.py</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HBase&quot;&gt;&lt;a href=&quot;#HBase&quot; class=&quot;headerlink&quot; title=&quot;HBase&quot;&gt;&lt;/a&gt;HBase&lt;/h1&gt;&lt;h2 id=&quot;在HBase环境下，创建student表&quot;&gt;&lt;a href=&quot;#在HBase环境下，创建student表&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker学习</title>
    <link href="http://example.com/2020/10/05/docker/"/>
    <id>http://example.com/2020/10/05/docker/</id>
    <published>2020-10-05T13:49:18.351Z</published>
    <updated>2020-10-05T14:14:21.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker学习"><a href="#Docker学习" class="headerlink" title="Docker学习"></a>Docker学习</h1><br><h2 id="1-Docker简介"><a href="#1-Docker简介" class="headerlink" title="1.Docker简介"></a>1.Docker简介</h2><h3 id="1-1-什么是虚拟化"><a href="#1-1-什么是虚拟化" class="headerlink" title="1.1 什么是虚拟化"></a>1.1 什么是虚拟化</h3><p>　　在计算机中，虚拟化（Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，<br>予以抽象、转换后呈现出来，打破实体结构间的不可分割的障碍，使用户可以比原来的组态更好的方式来应用这些资源。这些资源的<br>新虚拟部分是不受现有资源的架设方式、地域或物理组态所限制的。一般所指的虚拟化资源包括计算能力和资料存储。<br><br></p><p>　　虚拟化的技术有很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化、桌面虚拟化、服务虚拟化和虚拟机等。</p><h3 id="1-2-什么是Docker"><a href="#1-2-什么是Docker" class="headerlink" title="1.2 什么是Docker"></a>1.2 什么是Docker</h3><p>　　Docker是一个开源项目，诞生于2013年初，基于Go语言实现的。后来加入Linux基金会，遵从Apache2.0协议，项目代码在Github<br>上进行维护。</p><p>　　Docker的基础是Linux，与虚拟机不同的是，Docker只能虚拟出与宿主机相同的容器，但是占用的空间非常小，运行效率非常高。</p><h3 id="1-3-Docker的组件"><a href="#1-3-Docker的组件" class="headerlink" title="1.3 Docker的组件"></a>1.3 Docker的组件</h3><ul><li>服务器与客户端 <br><br>　　Docker是一个客户端与服务器（C/S）架构程序。客户端向服务器或守护进程发出请求，服务器或守护进程将完成工作并返回结果。</li><li>镜像与容器 <br><br>　　镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建部分”。镜像是基于联合文件系统<br>的一种层式结构，有一系列指令一步一步构建出来。<br><br>　　容器是基于镜像启动起来的，容器中可以运行一个或多个进程。镜像是Docker生命周期中的构建或是打包阶段，而容器则是启动或<br>执行阶段。容器时基于镜像启动，一旦容器启动完成后，就可以在容器中安装自己需要的软件和服务。</li><li>Registry（注册中心）<br><br>　　Docker用Registry来保存用户构建的镜像。分为公有和私有两部分，Docker公司运营公共的Registry叫做Docker Hub。用户可以<br>在Docker Hub注册账号，分享并保存自己的镜像。（Docker Hub 下在巨慢，可以构建自己的Registry）。<br></li></ul><p>　　<a href="https://hub.docker.com/">Registry Hub</a><br><br></p><h2 id="2-Docker安装与启动"><a href="#2-Docker安装与启动" class="headerlink" title="2.Docker安装与启动"></a>2.Docker安装与启动</h2><h3 id="2-1-安装Docker"><a href="#2-1-安装Docker" class="headerlink" title="2.1 安装Docker"></a>2.1 安装Docker</h3><ul><li>ubuntu 安装<ul><li>apt-get 更新 <br><br><code>sudo apt-get update</code></li><li>安装Docker <br><br><code>sudo apt-get install docker.io</code></li><li>查看版本 <br><br><code>docker -v</code></li></ul></li><li>centos 安装<ul><li>yum源更新 <br><br><code>sudo yum update</code></li><li>安装需要的软件包，yum-util提供yum-config-manager功能，另外两个是device-mapper驱动依赖的 <br><br><code>sudo yum install -y yum-utils device-mapper-presistent-data lvm2</code></li><li>设置yum源为阿里源 <br><br><code>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></li><li>安装Docker <br><br><code>sudo yum install docker-ce</code></li><li>查看版本 <br><br><code>docker -v</code></li></ul></li></ul><h3 id="2-2-设置ustc的镜像"><a href="#2-2-设置ustc的镜像" class="headerlink" title="2.2 设置ustc的镜像"></a>2.2 设置ustc的镜像</h3><p>　　ustc是老牌的Linux镜像服务提供者了，还在遥远的Ubuntu5.04版本的时候就在用。ustc的docker镜像加速器速度很快。<br>ustc docker mirror 的优势之一就是不需要注册，是真正的提供服务。</p><p>　　<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p><p>　　编辑该文件：<br></p><p>　　<code>vim /etc/docker/daemon.json</code><br>　　<br>　　在文件中添加如下内容： <br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;registry-mirrors&quot;</span>:[<span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="2-3-Docker的启动与停止"><a href="#2-3-Docker的启动与停止" class="headerlink" title="2.3 Docker的启动与停止"></a>2.3 Docker的启动与停止</h3><p><strong>systemctl</strong>命令是系统服务管理器指令</p><ul><li>启动docker <br><br><code>systemctl start docker</code></li><li>停止docker <br><br><code>systemctl stop docker</code></li><li>重启docker <br><br><code>systemctl restart docker</code></li><li>查看docker状态 <br><br><code>systemctl status docker</code></li><li>开机启动 <br><br><code>systemctl enable docker</code></li><li>查看docker概要信息 <br><br><code>docker info</code></li><li>查看docker帮助文档 <br><br><code>docker --help</code></li></ul><br><h2 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3. 常用命令"></a>3. 常用命令</h2><h3 id="3-1-镜像相关命令"><a href="#3-1-镜像相关命令" class="headerlink" title="3.1 镜像相关命令"></a>3.1 镜像相关命令</h3><ul><li>查看镜像 <br><br><code>docker images</code> <br></li></ul><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>REPOSITORY</td><td>镜像名称</td></tr><tr><td>TAG</td><td>镜像标签</td></tr><tr><td>IMAGE ID</td><td>镜像ID</td></tr><tr><td>CREATED</td><td>镜像的创建日期</td></tr><tr><td>SIZE</td><td>镜像大小</td></tr></tbody></table><ul><li>搜索镜像（需要从网络中查找需要的镜像） <br><br><code>docker search 镜像名称</code> <br></li></ul><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>NAME</td><td>仓库名称</td></tr><tr><td>DESCRIPTION</td><td>镜像描述</td></tr><tr><td>STARS</td><td>用户评价，反应一个镜像的受欢迎程度</td></tr><tr><td>OFFICIAL</td><td>是否官方</td></tr><tr><td>AUTOMATED</td><td>自动创建，表示该镜像有Docker Hub自动构建流程创建的</td></tr></tbody></table><ul><li><p>拉取镜像（从中央仓库下载到本地） <br><br><code>docker pull 镜像名称</code> <br></p><p>  例如，下载centos7镜像 <br><br>  <code>docker pull centos:7</code></p></li><li><p>删除镜像 <br><br><code>docker rmi 镜像ID</code> <br><br>  删除所有镜像 <br><br>  <code>docker rmi `docker images -q` </code>   注意`,不是’</p><br></li></ul><h3 id="3-2-容器相关命令"><a href="#3-2-容器相关命令" class="headerlink" title="3.2 容器相关命令"></a>3.2 容器相关命令</h3><ul><li>查看容器<ul><li>查看正在运行的容器 <br><br><code>docker ps</code></li><li>查看所有容器 <br><br><code>docker ps -s</code></li><li>查看最后一次运行的容器 <br><br><code>docker ps -l</code></li><li>查看停止的容器 <br><br><code>docker ps -f status=exited</code></li></ul></li><li>创建与启动容器<ul><li>创建容器命令与参数说明 <br><br><code>docker run [参数]</code></li></ul></li></ul><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-i</td><td>表示运行容器</td></tr><tr><td>-t</td><td>表示容器启动后会进入其命令行，加入这两个参数后，容器创建就能登录进去，即分配一个伪终端</td></tr><tr><td>–name</td><td>为创建的容器命名</td></tr><tr><td>-v</td><td>表示目录映射关系（前者是宿主机目录，后者是映射到宿主机的目录），可以使用多个-v做多个目录或文件映射。注意，最好做目录映射，在宿主机上做修改，然后共享到容器上</td></tr><tr><td>-d</td><td>表示创建一个守护式容器在后台运行（这样创建的容器不会自动登录容器，如果只加-i,-t两个参数，创建后就会自动进入容器</td></tr><tr><td>-p</td><td>表示端口映射，前者是宿主机端口，后者是容器内的映射端口，可以使用多个-p做多个端口映射</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker学习&quot;&gt;&lt;a href=&quot;#Docker学习&quot; class=&quot;headerlink&quot; title=&quot;Docker学习&quot;&gt;&lt;/a&gt;Docker学习&lt;/h1&gt;&lt;br&gt;

&lt;h2 id=&quot;1-Docker简介&quot;&gt;&lt;a href=&quot;#1-Docker简介&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/10/05/hello-world/"/>
    <id>http://example.com/2020/10/05/hello-world/</id>
    <published>2020-10-05T13:14:45.153Z</published>
    <updated>2020-10-05T13:14:45.153Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
